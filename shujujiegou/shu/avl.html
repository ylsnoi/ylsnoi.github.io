<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL树 - 姚老师信奥网</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4A80F0', // 主色调：鲜明的蓝色
                        secondary: '#6C63FF', // 辅助色：紫色
                        syntax: '#FF9800', // 语法部分：橙色
                        algorithm: '#2ECC71', // 算法部分：绿色
                        datastructure: '#9C27B0', // 数据结构部分：深紫色
                        darkbg: '#F8FAFC', // 浅灰白背景
                        cardbg: '#FFFFFF', // 卡片背景
                        hoverbg: '#F0F2F5', // 悬停背景
                        avl: '#E91E63', // AVL树主题色：粉红色
                        execution: '#FFEB3B', // 执行高亮：黄色
                    },
                    fontFamily: {
                        mono: ['Consolas', 'Monaco', 'Courier New', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .hover-scale {
                @apply transition-transform duration-300 hover:scale-[1.02];
            }
            .category-bg {
                @apply bg-gradient-to-r from-primary/5 to-primary/10;
            }
            .subcategory-bg {
                @apply bg-gradient-to-r from-secondary/5 to-secondary/10;
            }
            .avl-bg {
                @apply bg-gradient-to-r from-avl/5 to-avl/10;
            }
            .card-shadow {
                @apply shadow-sm hover:shadow-md transition-shadow duration-300;
            }
            .nav-item {
                @apply text-gray-700 hover:text-primary transition-colors duration-200;
            }
            .topic-card {
                @apply bg-cardbg rounded-lg p-5 card-shadow hover-scale;
            }
            .subtopic-item {
                @apply bg-white rounded-md p-3 border border-gray-100 hover:border-primary/50 transition-all duration-200 cursor-pointer;
            }
            .topic-header {
                @apply text-xl font-bold text-primary mb-4 flex items-center;
            }
            .subtopic-header {
                @apply font-semibold text-secondary mb-3;
            }
            .avl-header {
                @apply font-bold text-avl mb-3;
            }
            .site-title {
                @apply text-2xl font-bold text-primary tracking-tight;
            }
            .code-block {
                @apply bg-gray-800 text-gray-100 rounded-lg p-4 overflow-x-auto my-4 text-sm font-mono;
            }
            .step-item {
                @apply p-3 rounded-md mb-2 border-l-4 border-avl bg-avl/5;
            }
            .step-number {
                @apply inline-block w-6 h-6 rounded-full bg-avl text-white text-center mr-2 text-xs;
            }
            .node {
                @apply w-12 h-12 rounded-full bg-primary text-white flex items-center justify-center font-bold border-2 border-white mx-auto;
            }
            .node-current {
                @apply bg-avl scale-110;
            }
            .node-balanced {
                @apply bg-algorithm;
            }
            .node-unbalanced {
                @apply bg-red-500;
            }
            .edge {
                @apply border-t-2 border-gray-400 w-8 mx-auto;
            }
            .edge-left {
                @apply border-l-2 border-gray-400 h-8;
            }
            .edge-right {
                @apply border-r-2 border-gray-400 h-8;
            }
            .tree-level {
                @apply flex justify-center items-center;
            }
            .animation-controls {
                @apply flex flex-wrap gap-2 items-center my-4;
            }
            .animation-step {
                @apply bg-gray-100 p-3 rounded-lg mb-4;
            }
            .animation-progress {
                @apply w-full bg-gray-200 rounded-full h-2.5 mb-2;
            }
            .animation-progress-bar {
                @apply bg-avl h-2.5 rounded-full transition-all duration-300;
            }
            .animation-status {
                @apply text-sm text-gray-600 my-2 p-2 bg-gray-50 rounded;
            }
            .code-line {
                @apply transition-all duration-300;
            }
            .code-line-highlight {
                @apply bg-execution/30 text-gray-900 font-medium;
            }
        }
    </style>
</head>
<body class="bg-darkbg text-gray-800 font-sans min-h-screen">
    <!-- 顶部导航栏 -->
    <header class="bg-white shadow-sm sticky top-0 z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <i class="fa fa-code text-primary text-3xl"></i>
                <h1 class="site-title">姚老师信奥网</h1>
            </div>
            <div class="hidden md:flex items-center space-x-6">
                <a href="#" class="nav-item">首页</a>
                <a href="#" class="nav-item">课程</a>
                <a href="#" class="nav-item">题库</a>
                <a href="#" class="nav-item">关于我们</a>
            </div>
            <div class="flex items-center space-x-4">
                <!-- 搜索框 -->
                <div class="relative hidden md:block">
                    <input type="text" id="search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-64">
                    <button id="search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                        <i class="fa fa-search"></i>
                    </button>
                </div>
                <div class="md:hidden">
                    <button class="text-gray-700">
                        <i class="fa fa-bars text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
        <!-- 移动端搜索框 -->
        <div class="md:hidden px-4 pb-3">
            <div class="relative">
                <input type="text" id="mobile-search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-full">
                <button id="mobile-search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                    <i class="fa fa-search"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- 面包屑导航 -->
    <div class="bg-white border-b border-gray-200 py-2">
        <div class="container mx-auto px-4">
            <nav class="flex text-sm" aria-label="Breadcrumb">
                <ol class="inline-flex items-center space-x-1 md:space-x-3">
                    <li class="inline-flex items-center">
                        <a href="#" class="text-gray-600 hover:text-primary">
                            <i class="fa fa-home mr-1"></i>首页
                        </a>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary">数据结构</a>
                        </div>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary">树结构</a>
                        </div>
                    </li>
                    <li aria-current="page">
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <span class="text-avl font-medium">AVL树</span>
                        </div>
                    </li>
                </ol>
            </nav>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 页面标题 -->
        <div class="avl-bg rounded-lg p-6 mb-8">
            <div class="flex flex-col md:flex-row md:items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-avl mb-2">AVL树</h1>
                    <p class="text-gray-700">
                        AVL树是一种自平衡二叉搜索树，它能保持二叉树的高度平衡，从而保证查找、插入和删除操作的时间复杂度为O(log n)。
                        本页面将详细讲解AVL树的定义、旋转操作、插入和删除算法，帮助NOIP竞赛学生掌握这一重要数据结构。
                    </p>
                </div>
                <div class="mt-4 md:mt-0">
                    <div class="flex space-x-3">
                        <a href="#concept" class="bg-avl hover:bg-avl/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-book mr-2"></i> 学习概念
                        </a>
                        <a href="#problems" class="bg-white border border-avl text-avl hover:bg-avl/5 px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-list-alt mr-2"></i> 查看题目
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- AVL树概述 -->
        <section id="concept" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-avl mb-6 flex items-center">
                <i class="fa fa-info-circle mr-2"></i> AVL树概述
            </h2>
            <div class="space-y-4">
                <div>
                    <h3 class="text-xl font-semibold mb-3">什么是AVL树？</h3>
                    <p class="text-gray-700">
                        AVL树是以发明者Adelson-Velsky和Landis命名的自平衡二叉搜索树。它的特点是每个节点的左右两个子树的高度差（平衡因子）的绝对值不超过1。
                        这一特性保证了树的高度始终保持在O(log n)级别，从而确保了高效的查找、插入和删除操作。
                    </p>
                    <div class="bg-gray-50 p-4 rounded-lg mt-3">
                        <h4 class="font-semibold mb-2">AVL树的重要概念：</h4>
                        <ul class="list-disc pl-5 space-y-2">
                            <li><strong>平衡因子</strong>：节点的左子树高度减去右子树高度的值（取值范围：-1, 0, 1）</li>
                            <li><strong>自平衡</strong>：通过旋转操作自动维持树的平衡状态</li>
                            <li><strong>搜索性能</strong>：查找、插入、删除操作的时间复杂度均为O(log n)</li>
                            <li><strong>适用场景</strong>：需要频繁进行插入、删除和查找操作的场景</li>
                        </ul>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-3">AVL树的节点结构</h3>
                    <p class="text-gray-700 mb-3">
                        AVL树的节点除了存储键值、左孩子和右孩子指针外，还需要存储节点的高度信息，用于计算平衡因子：
                    </p>
                    <pre class="code-block"><code class="language-cpp">struct AVLNode {
    int key;               // 节点存储的值
    int height;            // 节点的高度
    AVLNode *left;         // 左孩子指针
    AVLNode *right;        // 右孩子指针
    
    // 构造函数
    AVLNode(int k) : key(k), height(1), left(nullptr), right(nullptr) {}
};</code></pre>
                    
                    <div class="mt-4">
                        <h4 class="font-semibold mb-2">平衡因子的计算</h4>
                        <pre class="code-block"><code class="language-cpp">// 获取节点的高度，空节点高度为0
int getHeight(AVLNode *node) {
    return (node == nullptr) ? 0 : node->height;
}

// 计算平衡因子：左子树高度 - 右子树高度
int getBalanceFactor(AVLNode *node) {
    return (node == nullptr) ? 0 : getHeight(node->left) - getHeight(node->right);
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- 旋转操作动画演示 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-avl mb-6 flex items-center">
                <i class="fa fa-refresh mr-2"></i> AVL树旋转操作演示
            </h2>
            
            <div class="space-y-6">
                <!-- 旋转操作动画 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">AVL树四种旋转操作演示</h3>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-1">
                            <p class="text-gray-700 mb-4">
                                当AVL树失去平衡时，需要通过旋转操作来恢复平衡。AVL树有四种基本旋转操作：
                                左旋转、右旋转、左右旋转和右左旋转。
                            </p>
                            
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">选择旋转类型:</label>
                                <select id="rotation-type" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-avl">
                                    <option value="right">右旋转 (LL型)</option>
                                    <option value="left">左旋转 (RR型)</option>
                                    <option value="left-right">左右旋转 (LR型)</option>
                                    <option value="right-left">右左旋转 (RL型)</option>
                                </select>
                            </div>
                            
                            <div class="flex space-x-2">
                                <button id="rotation-run" class="bg-avl hover:bg-avl/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-play mr-2"></i> 运行动画
                                </button>
                                <button id="rotation-reset" class="bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-refresh mr-2"></i> 重置
                                </button>
                            </div>
                            
                            <div id="rotation-status" class="animation-status hidden">
                                状态: 等待开始
                            </div>
                            
                            <div class="mt-4 bg-white p-3 rounded border border-gray-200">
                                <h4 class="font-semibold text-sm mb-2">旋转步骤说明:</h4>
                                <ol id="rotation-steps" class="text-sm text-gray-700 list-decimal pl-5 space-y-1">
                                    <li>选择旋转类型，点击"运行动画"按钮</li>
                                    <li>观察树从失衡状态到平衡状态的转变</li>
                                    <li>查看代码执行过程和高亮显示</li>
                                </ol>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-white border border-gray-200 rounded-lg p-4 h-80 overflow-y-auto flex items-center justify-center" id="tree-visualization">
                                <div class="text-center text-gray-500 py-8">
                                    <i class="fa fa-tree mb-2 text-2xl"></i>
                                    <p>选择旋转类型并点击"运行动画"</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-gray-800 text-gray-100 rounded-lg p-4 h-80 overflow-y-auto font-mono text-sm" id="rotation-code">
                                <div class="code-line" id="rotate-code-1">// 右旋转操作</div>
                                <div class="code-line" id="rotate-code-2">AVLNode* rightRotate(AVLNode* y) {</div>
                                <div class="code-line" id="rotate-code-3">&nbsp;&nbsp;AVLNode* x = y->left;</div>
                                <div class="code-line" id="rotate-code-4">&nbsp;&nbsp;AVLNode* T2 = x->right;</div>
                                <div class="code-line" id="rotate-code-5">&nbsp;</div>
                                <div class="code-line" id="rotate-code-6">&nbsp;&nbsp;// 执行旋转</div>
                                <div class="code-line" id="rotate-code-7">&nbsp;&nbsp;x->right = y;</div>
                                <div class="code-line" id="rotate-code-8">&nbsp;&nbsp;y->left = T2;</div>
                                <div class="code-line" id="rotate-code-9">&nbsp;</div>
                                <div class="code-line" id="rotate-code-10">&nbsp;&nbsp;// 更新高度</div>
                                <div class="code-line" id="rotate-code-11">&nbsp;&nbsp;y->height = 1 + max(getHeight(y->left),</div>
                                <div class="code-line" id="rotate-code-12">&nbsp;&nbsp;&nbsp;&nbsp;getHeight(y->right));</div>
                                <div class="code-line" id="rotate-code-13">&nbsp;&nbsp;x->height = 1 + max(getHeight(x->left),</div>
                                <div class="code-line" id="rotate-code-14">&nbsp;&nbsp;&nbsp;&nbsp;getHeight(x->right));</div>
                                <div class="code-line" id="rotate-code-15">&nbsp;</div>
                                <div class="code-line" id="rotate-code-16">&nbsp;&nbsp;// 返回新的根节点</div>
                                <div class="code-line" id="rotate-code-17">&nbsp;&nbsp;return x;</div>
                                <div class="code-line" id="rotate-code-18">}</div>
                                <div class="code-line" id="rotate-code-19">&nbsp;</div>
                                <div class="code-line" id="rotate-code-20">// 左旋转操作</div>
                                <div class="code-line" id="rotate-code-21">AVLNode* leftRotate(AVLNode* x) {</div>
                                <div class="code-line" id="rotate-code-22">&nbsp;&nbsp;AVLNode* y = x->right;</div>
                                <div class="code-line" id="rotate-code-23">&nbsp;&nbsp;AVLNode* T2 = y->left;</div>
                                <div class="code-line" id="rotate-code-24">&nbsp;</div>
                                <div class="code-line" id="rotate-code-25">&nbsp;&nbsp;// 执行旋转</div>
                                <div class="code-line" id="rotate-code-26">&nbsp;&nbsp;y->left = x;</div>
                                <div class="code-line" id="rotate-code-27">&nbsp;&nbsp;x->right = T2;</div>
                                <div class="code-line" id="rotate-code-28">&nbsp;</div>
                                <div class="code-line" id="rotate-code-29">&nbsp;&nbsp;// 更新高度</div>
                                <div class="code-line" id="rotate-code-30">&nbsp;&nbsp;x->height = 1 + max(getHeight(x->left),</div>
                                <div class="code-line" id="rotate-code-31">&nbsp;&nbsp;&nbsp;&nbsp;getHeight(x->right));</div>
                                <div class="code-line" id="rotate-code-32">&nbsp;&nbsp;y->height = 1 + max(getHeight(y->left),</div>
                                <div class="code-line" id="rotate-code-33">&nbsp;&nbsp;&nbsp;&nbsp;getHeight(y->right));</div>
                                <div class="code-line" id="rotate-code-34">&nbsp;</div>
                                <div class="code-line" id="rotate-code-35">&nbsp;&nbsp;// 返回新的根节点</div>
                                <div class="code-line" id="rotate-code-36">&nbsp;&nbsp;return y;</div>
                                <div class="code-line" id="rotate-code-37">}</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 旋转类型说明 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">四种旋转类型适用场景</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="bg-white p-4 rounded-lg border border-gray-200">
                            <h4 class="font-semibold text-avl mb-2">右旋转 (LL型)</h4>
                            <p class="text-gray-700 text-sm mb-2">
                                当节点的左子树的左子树过高（平衡因子为2，左孩子平衡因子≥0）时使用。
                            </p>
                            <div class="flex justify-center py-2">
                                <div class="text-center">
                                    <div class="node">y</div>
                                    <div class="edge"></div>
                                    <div class="tree-level">
                                        <div>
                                            <div class="node">x</div>
                                            <div class="edge-left"></div>
                                            <div class="node">A</div>
                                        </div>
                                        <div class="edge-right"></div>
                                        <div class="node">B</div>
                                    </div>
                                    <div class="text-xs text-gray-500 mt-2">右旋转后x成为新根</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-white p-4 rounded-lg border border-gray-200">
                            <h4 class="font-semibold text-avl mb-2">左旋转 (RR型)</h4>
                            <p class="text-gray-700 text-sm mb-2">
                                当节点的右子树的右子树过高（平衡因子为-2，右孩子平衡因子≤0）时使用。
                            </p>
                            <div class="flex justify-center py-2">
                                <div class="text-center">
                                    <div class="node">x</div>
                                    <div class="edge"></div>
                                    <div class="tree-level">
                                        <div class="node">A</div>
                                        <div class="edge-left"></div>
                                        <div>
                                            <div class="node">y</div>
                                            <div class="edge-right"></div>
                                            <div class="node">B</div>
                                        </div>
                                    </div>
                                    <div class="text-xs text-gray-500 mt-2">左旋转后y成为新根</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-white p-4 rounded-lg border border-gray-200">
                            <h4 class="font-semibold text-avl mb-2">左右旋转 (LR型)</h4>
                            <p class="text-gray-700 text-sm mb-2">
                                当节点的左子树的右子树过高（平衡因子为2，左孩子平衡因子≤-1）时使用，先左旋转再右旋转。
                            </p>
                            <div class="flex justify-center py-2">
                                <div class="text-center">
                                    <div class="node">z</div>
                                    <div class="edge"></div>
                                    <div class="tree-level">
                                        <div>
                                            <div class="node">x</div>
                                            <div class="edge-right"></div>
                                            <div class="node">y</div>
                                        </div>
                                        <div class="edge-right"></div>
                                        <div class="node">C</div>
                                    </div>
                                    <div class="text-xs text-gray-500 mt-2">先左旋转x，再右旋转z</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-white p-4 rounded-lg border border-gray-200">
                            <h4 class="font-semibold text-avl mb-2">右左旋转 (RL型)</h4>
                            <p class="text-gray-700 text-sm mb-2">
                                当节点的右子树的左子树过高（平衡因子为-2，右孩子平衡因子≥1）时使用，先右旋转再左旋转。
                            </p>
                            <div class="flex justify-center py-2">
                                <div class="text-center">
                                    <div class="node">z</div>
                                    <div class="edge"></div>
                                    <div class="tree-level">
                                        <div class="node">A</div>
                                        <div class="edge-left"></div>
                                        <div>
                                            <div class="node">y</div>
                                            <div class="edge-left"></div>
                                            <div class="node">x</div>
                                        </div>
                                    </div>
                                    <div class="text-xs text-gray-500 mt-2">先右旋转y，再左旋转z</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- AVL树插入操作 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-avl mb-6 flex items-center">
                <i class="fa fa-plus-circle mr-2"></i> AVL树插入操作
            </h2>
            
            <div class="space-y-6">
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">AVL树插入过程演示</h3>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-1">
                            <p class="text-gray-700 mb-4">
                                AVL树的插入操作在普通二叉搜索树插入的基础上，增加了平衡检查和旋转调整步骤，以保持树的平衡状态。
                            </p>
                            
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">输入插入序列（逗号分隔）:</label>
                                <input type="text" id="insert-values" value="30,20,10,40,50,60" 
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-avl">
                            </div>
                            
                            <div class="flex space-x-2">
                                <button id="insert-run" class="bg-avl hover:bg-avl/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-play mr-2"></i> 运行插入
                                </button>
                                <button id="insert-step" class="bg-secondary hover:bg-secondary/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-step-forward mr-2"></i> 单步执行
                                </button>
                                <button id="insert-reset" class="bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-refresh mr-2"></i> 重置
                                </button>
                            </div>
                            
                            <div id="insert-status" class="animation-status hidden">
                                状态: 等待开始
                            </div>
                            
                            <div class="animation-progress">
                                <div id="insert-progress-bar" class="animation-progress-bar" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-white border border-gray-200 rounded-lg p-4 h-80 overflow-y-auto flex items-center justify-center" id="insert-tree-visualization">
                                <div class="text-center text-gray-500 py-8">
                                    <i class="fa fa-tree mb-2 text-2xl"></i>
                                    <p>点击"运行插入"或"单步执行"</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-gray-800 text-gray-100 rounded-lg p-4 h-80 overflow-y-auto font-mono text-sm" id="insert-code">
                                <div class="code-line" id="insert-code-1">// AVL树插入函数</div>
                                <div class="code-line" id="insert-code-2">AVLNode* insert(AVLNode* node, int key) {</div>
                                <div class="code-line" id="insert-code-3">&nbsp;&nbsp;// 1. 执行标准BST插入</div>
                                <div class="code-line" id="insert-code-4">&nbsp;&nbsp;if (node == nullptr) {</div>
                                <div class="code-line" id="insert-code-5">&nbsp;&nbsp;&nbsp;&nbsp;return new AVLNode(key);</div>
                                <div class="code-line" id="insert-code-6">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="insert-code-7">&nbsp;</div>
                                <div class="code-line" id="insert-code-8">&nbsp;&nbsp;if (key < node->key) {</div>
                                <div class="code-line" id="insert-code-9">&nbsp;&nbsp;&nbsp;&nbsp;node->left = insert(node->left, key);</div>
                                <div class="code-line" id="insert-code-10">&nbsp;&nbsp;} else if (key > node->key) {</div>
                                <div class="code-line" id="insert-code-11">&nbsp;&nbsp;&nbsp;&nbsp;node->right = insert(node->right, key);</div>
                                <div class="code-line" id="insert-code-12">&nbsp;&nbsp;} else { // 不允许重复值</div>
                                <div class="code-line" id="insert-code-13">&nbsp;&nbsp;&nbsp;&nbsp;return node;</div>
                                <div class="code-line" id="insert-code-14">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="insert-code-15">&nbsp;</div>
                                <div class="code-line" id="insert-code-16">&nbsp;&nbsp;// 2. 更新当前节点的高度</div>
                                <div class="code-line" id="insert-code-17">&nbsp;&nbsp;node->height = 1 + max(getHeight(node->left),</div>
                                <div class="code-line" id="insert-code-18">&nbsp;&nbsp;&nbsp;&nbsp;getHeight(node->right));</div>
                                <div class="code-line" id="insert-code-19">&nbsp;</div>
                                <div class="code-line" id="insert-code-20">&nbsp;&nbsp;// 3. 计算平衡因子，检查是否失衡</div>
                                <div class="code-line" id="insert-code-21">&nbsp;&nbsp;int balance = getBalanceFactor(node);</div>
                                <div class="code-line" id="insert-code-22">&nbsp;</div>
                                <div class="code-line" id="insert-code-23">&nbsp;&nbsp;// 4. 如果失衡，进行旋转处理</div>
                                <div class="code-line" id="insert-code-24">&nbsp;&nbsp;// LL型：左左情况，右旋转</div>
                                <div class="code-line" id="insert-code-25">&nbsp;&nbsp;if (balance > 1 && key < node->left->key) {</div>
                                <div class="code-line" id="insert-code-26">&nbsp;&nbsp;&nbsp;&nbsp;return rightRotate(node);</div>
                                <div class="code-line" id="insert-code-27">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="insert-code-28">&nbsp;</div>
                                <div class="code-line" id="insert-code-29">&nbsp;&nbsp;// RR型：右右情况，左旋转</div>
                                <div class="code-line" id="insert-code-30">&nbsp;&nbsp;if (balance < -1 && key > node->right->key) {</div>
                                <div class="code-line" id="insert-code-31">&nbsp;&nbsp;&nbsp;&nbsp;return leftRotate(node);</div>
                                <div class="code-line" id="insert-code-32">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="insert-code-33">&nbsp;</div>
                                <div class="code-line" id="insert-code-34">&nbsp;&nbsp;// LR型：左右情况，先左旋转再右旋转</div>
                                <div class="code-line" id="insert-code-35">&nbsp;&nbsp;if (balance > 1 && key > node->left->key) {</div>
                                <div class="code-line" id="insert-code-36">&nbsp;&nbsp;&nbsp;&nbsp;node->left = leftRotate(node->left);</div>
                                <div class="code-line" id="insert-code-37">&nbsp;&nbsp;&nbsp;&nbsp;return rightRotate(node);</div>
                                <div class="code-line" id="insert-code-38">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="insert-code-39">&nbsp;</div>
                                <div class="code-line" id="insert-code-40">&nbsp;&nbsp;// RL型：右左情况，先右旋转再左旋转</div>
                                <div class="code-line" id="insert-code-41">&nbsp;&nbsp;if (balance < -1 && key < node->right->key) {</div>
                                <div class="code-line" id="insert-code-42">&nbsp;&nbsp;&nbsp;&nbsp;node->right = rightRotate(node->right);</div>
                                <div class="code-line" id="insert-code-43">&nbsp;&nbsp;&nbsp;&nbsp;return leftRotate(node);</div>
                                <div class="code-line" id="insert-code-44">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="insert-code-45">&nbsp;</div>
                                <div class="code-line" id="insert-code-46">&nbsp;&nbsp;// 5. 返回未改变的节点指针</div>
                                <div class="code-line" id="insert-code-47">&nbsp;&nbsp;return node;</div>
                                <div class="code-line" id="insert-code-48">}</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">插入操作步骤解析</h3>
                    <div class="space-y-3">
                        <div class="step-item">
                            <span class="step-number">1</span>
                            <strong>标准BST插入</strong>：按照二叉搜索树的规则插入新节点
                        </div>
                        <div class="step-item">
                            <span class="step-number">2</span>
                            <strong>更新高度</strong>：从新插入节点向上回溯，更新所有祖先节点的高度
                        </div>
                        <div class="step-item">
                            <span class="step-number">3</span>
                            <strong>检查平衡</strong>：计算每个节点的平衡因子，判断是否失衡（平衡因子绝对值>1）
                        </div>
                        <div class="step-item">
                            <span class="step-number">4</span>
                            <strong>平衡调整</strong>：如果失衡，根据失衡类型选择相应的旋转操作恢复平衡
                        </div>
                        <div class="step-item">
                            <span class="step-number">5</span>
                            <strong>返回结果</strong>：返回调整后的节点指针
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- AVL树完整实现 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-avl mb-6 flex items-center">
                <i class="fa fa-code mr-2"></i> AVL树完整实现 (C++)
            </h2>
            
            <div class="space-y-6">
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">AVL树完整代码实现</h3>
                    <p class="text-gray-700 mb-3">
                        下面是AVL树的完整C++实现，包括节点定义、旋转操作、插入、删除和遍历等功能：
                    </p>
                    
                    <pre class="code-block"><code class="language-cpp">#include <iostream>
#include <algorithm>
using namespace std;

// AVL树节点结构
struct AVLNode {
    int key;               // 节点存储的值
    int height;            // 节点的高度
    AVLNode *left;         // 左孩子指针
    AVLNode *right;        // 右孩子指针
    
    // 构造函数
    AVLNode(int k) : key(k), height(1), left(nullptr), right(nullptr) {}
};

// 获取节点的高度，空节点高度为0
int getHeight(AVLNode *node) {
    return (node == nullptr) ? 0 : node->height;
}

// 计算平衡因子：左子树高度 - 右子树高度
int getBalanceFactor(AVLNode *node) {
    return (node == nullptr) ? 0 : getHeight(node->left) - getHeight(node->right);
}

// 右旋转操作
AVLNode* rightRotate(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;
    
    // 执行旋转
    x->right = y;
    y->left = T2;
    
    // 更新高度
    y->height = 1 + max(getHeight(y->left), getHeight(y->right));
    x->height = 1 + max(getHeight(x->left), getHeight(x->right));
    
    // 返回新的根节点
    return x;
}

// 左旋转操作
AVLNode* leftRotate(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* T2 = y->left;
    
    // 执行旋转
    y->left = x;
    x->right = T2;
    
    // 更新高度
    x->height = 1 + max(getHeight(x->left), getHeight(x->right));
    y->height = 1 + max(getHeight(y->left), getHeight(y->right));
    
    // 返回新的根节点
    return y;
}

// AVL树插入函数
AVLNode* insert(AVLNode* node, int key) {
    // 1. 执行标准BST插入
    if (node == nullptr) {
        return new AVLNode(key);
    }
    
    if (key < node->key) {
        node->left = insert(node->left, key);
    } else if (key > node->key) {
        node->right = insert(node->right, key);
    } else { // 不允许重复值
        return node;
    }
    
    // 2. 更新当前节点的高度
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));
    
    // 3. 计算平衡因子，检查是否失衡
    int balance = getBalanceFactor(node);
    
    // 4. 如果失衡，进行旋转处理
    // LL型：左左情况，右旋转
    if (balance > 1 && key < node->left->key) {
        return rightRotate(node);
    }
    
    // RR型：右右情况，左旋转
    if (balance < -1 && key > node->right->key) {
        return leftRotate(node);
    }
    
    // LR型：左右情况，先左旋转再右旋转
    if (balance > 1 && key > node->left->key) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    
    // RL型：右左情况，先右旋转再左旋转
    if (balance < -1 && key < node->right->key) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }
    
    // 5. 返回未改变的节点指针
    return node;
}

// 找到以node为根的树中的最小值节点
AVLNode* findMinNode(AVLNode* node) {
    AVLNode* current = node;
    // 循环找到最左节点
    while (current->left != nullptr) {
        current = current->left;
    }
    return current;
}

// AVL树删除函数
AVLNode* deleteNode(AVLNode* root, int key) {
    // 1. 标准BST删除
    if (root == nullptr) {
        return root; // 未找到要删除的节点
    }
    
    // 递归查找要删除的节点
    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    } else { // 找到要删除的节点
        // 情况1：叶子节点或只有一个子节点
        if ((root->left == nullptr) || (root->right == nullptr)) {
            AVLNode* temp = root->left ? root->left : root->right;
            
            // 子节点都为空的情况
            if (temp == nullptr) {
                temp = root;
                root = nullptr;
            } else { // 一个子节点的情况
                *root = *temp; // 复制子节点内容
            }
            delete temp;
        } else { // 情况2：有两个子节点
            // 找到中序后继（右子树的最小值节点）
            AVLNode* temp = findMinNode(root->right);
            
            // 复制中序后继的值到当前节点
            root->key = temp->key;
            
            // 删除中序后继
            root->right = deleteNode(root->right, temp->key);
        }
    }
    
    // 如果树只有一个节点，删除后为空树
    if (root == nullptr) {
        return root;
    }
    
    // 2. 更新当前节点的高度
    root->height = 1 + max(getHeight(root->left), getHeight(root->right));
    
    // 3. 计算平衡因子，检查是否失衡
    int balance = getBalanceFactor(root);
    
    // 4. 如果失衡，进行旋转处理
    // LL型
    if (balance > 1 && getBalanceFactor(root->left) >= 0) {
        return rightRotate(root);
    }
    
    // LR型
    if (balance > 1 && getBalanceFactor(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }
    
    // RR型
    if (balance < -1 && getBalanceFactor(root->right) <= 0) {
        return leftRotate(root);
    }
    
    // RL型
    if (balance < -1 && getBalanceFactor(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }
    
    return root;
}

// 中序遍历AVL树（升序）
void inorderTraversal(AVLNode* root) {
    if (root != nullptr) {
        inorderTraversal(root->left);
        cout << root->key << " ";
        inorderTraversal(root->right);
    }
}

// 前序遍历AVL树
void preorderTraversal(AVLNode* root) {
    if (root != nullptr) {
        cout << root->key << " ";
        preorderTraversal(root->left);
        preorderTraversal(root->right);
    }
}

// 查找指定值
bool search(AVLNode* root, int key) {
    if (root == nullptr) {
        return false;
    }
    if (key == root->key) {
        return true;
    } else if (key < root->key) {
        return search(root->left, key);
    } else {
        return search(root->right, key);
    }
}

// 主函数示例
int main() {
    AVLNode* root = nullptr;
    
    // 插入节点
    root = insert(root, 9);
    root = insert(root, 5);
    root = insert(root, 10);
    root = insert(root, 0);
    root = insert(root, 6);
    root = insert(root, 11);
    root = insert(root, -1);
    root = insert(root, 1);
    root = insert(root, 2);
    
    cout << "中序遍历: ";
    inorderTraversal(root);
    cout << endl;
    
    // 删除节点
    root = deleteNode(root, 10);
    
    cout << "删除10后中序遍历: ";
    inorderTraversal(root);
    cout << endl;
    
    // 查找节点
    int key = 6;
    cout << "查找" << key << ": " << (search(root, key) ? "找到" : "未找到") << endl;
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- 推荐题目 -->
        <section id="problems" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-avl mb-6 flex items-center">
                <i class="fa fa-tasks mr-2"></i> 推荐练习题目
            </h2>
            
            <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">模板题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P3369 【模板】普通平衡树</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">入门</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                实现一个能够支持插入、删除、查询排名、查询第k大等操作的平衡树。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P3369" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P6136 【模板】普通平衡树（数据加强版）</h4>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">提高</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                数据范围更大的平衡树模板题，考验实现效率。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P6136" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P5076 【深基16.例7】普通二叉树（简化版）</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">入门</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                简化版的二叉树操作题，适合初学者练习基本操作。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P5076" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">入门题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P1177 【模板】排序</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">入门</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                排序问题，可以用AVL树实现高效排序。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1177" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P1908 逆序对</h4>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">提高</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                统计逆序对数量，可以用平衡树高效实现。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1908" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P2234 营业额统计</h4>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">提高</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                维护一个动态集合，支持插入和查询最近值，适合用AVL树解决。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P2234" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">进阶题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P3391 【模板】文艺平衡树</h4>
                                <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">省选</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                带区间翻转操作的平衡树，需要在AVL树基础上增加额外功能。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P3391" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P4556 [Vani有约会] 雨天的尾巴</h4>
                                <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">省选</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                树上路径更新与查询问题，可结合树链剖分与平衡树解决。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P4556" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">洛谷 P2042 【NOI2005】维护数列</h4>
                                <span class="bg-red-100 text-red-800 text-xs px-2 py-1 rounded"> NOI</span>
                            </div>
                            <p class="text-gray-700 text-sm mb-3">
                                复杂的序列维护问题，需要实现功能完善的平衡树。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P2042" target="_blank" class="text-avl hover:text-avl/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        // 初始化代码高亮
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
            
            // 旋转动画演示
            initRotationDemo();
            
            // 插入动画演示
            initInsertDemo();
        });
        
        // 旋转动画演示初始化
        function initRotationDemo() {
            const rotationRunBtn = document.getElementById('rotation-run');
            const rotationResetBtn = document.getElementById('rotation-reset');
            const rotationType = document.getElementById('rotation-type');
            const rotationStatus = document.getElementById('rotation-status');
            const rotationSteps = document.getElementById('rotation-steps');
            const treeVisualization = document.getElementById('tree-visualization');
            
            // 显示状态
            rotationStatus.classList.remove('hidden');
            
            // 旋转步骤说明
            const rotationStepTexts = {
                'right': [
                    '1. 检测到LL型失衡（平衡因子为2，左孩子平衡因子≥0）',
                    '2. 对失衡节点执行右旋转',
                    '3. 旋转后，原左孩子成为新的根节点',
                    '4. 原根节点成为新根节点的右孩子',
                    '5. 调整完成，树恢复平衡'
                ],
                'left': [
                    '1. 检测到RR型失衡（平衡因子为-2，右孩子平衡因子≤0）',
                    '2. 对失衡节点执行左旋转',
                    '3. 旋转后，原右孩子成为新的根节点',
                    '4. 原根节点成为新根节点的左孩子',
                    '5. 调整完成，树恢复平衡'
                ],
                'left-right': [
                    '1. 检测到LR型失衡（平衡因子为2，左孩子平衡因子≤-1）',
                    '2. 先对左孩子执行左旋转',
                    '3. 再对原失衡节点执行右旋转',
                    '4. 旋转后，原左孩子的右孩子成为新的根节点',
                    '5. 调整完成，树恢复平衡'
                ],
                'right-left': [
                    '1. 检测到RL型失衡（平衡因子为-2，右孩子平衡因子≥1）',
                    '2. 先对右孩子执行右旋转',
                    '3. 再对原失衡节点执行左旋转',
                    '4. 旋转后，原右孩子的左孩子成为新的根节点',
                    '5. 调整完成，树恢复平衡'
                ]
            };
            
            // 树结构HTML
            const treeHtmls = {
                'right': {
                    initial: `
                        <div class="tree-container">
                            <div class="node node-unbalanced">30</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div>
                                    <div class="node">20</div>
                                    <div class="edge"></div>
                                    <div class="node">10</div>
                                </div>
                                <div class="edge-right"></div>
                                <div class="node">40</div>
                            </div>
                        </div>
                    `,
                    step1: `
                        <div class="tree-container">
                            <div class="node node-current node-unbalanced">30</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div>
                                    <div class="node">20</div>
                                    <div class="edge"></div>
                                    <div class="node">10</div>
                                </div>
                                <div class="edge-right"></div>
                                <div class="node">40</div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">检测到LL型失衡，准备右旋转</div>
                        </div>
                    `,
                    step2: `
                        <div class="tree-container">
                            <div class="node">20</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div class="node">10</div>
                                <div class="edge"></div>
                                <div class="node node-current">30</div>
                                <div class="edge-right"></div>
                                <div class="node">40</div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">右旋转完成，树恢复平衡</div>
                        </div>
                    `
                },
                'left': {
                    initial: `
                        <div class="tree-container">
                            <div class="node node-unbalanced">10</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div class="node">5</div>
                                <div class="edge-left"></div>
                                <div>
                                    <div class="node">20</div>
                                    <div class="edge"></div>
                                    <div class="node">30</div>
                                </div>
                            </div>
                        </div>
                    `,
                    step1: `
                        <div class="tree-container">
                            <div class="node node-current node-unbalanced">10</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div class="node">5</div>
                                <div class="edge-left"></div>
                                <div>
                                    <div class="node">20</div>
                                    <div class="edge"></div>
                                    <div class="node">30</div>
                                </div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">检测到RR型失衡，准备左旋转</div>
                        </div>
                    `,
                    step2: `
                        <div class="tree-container">
                            <div class="node">20</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div>
                                    <div class="node">10</div>
                                    <div class="edge-left"></div>
                                    <div class="node">5</div>
                                </div>
                                <div class="edge"></div>
                                <div class="node node-current">30</div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">左旋转完成，树恢复平衡</div>
                        </div>
                    `
                },
                'left-right': {
                    initial: `
                        <div class="tree-container">
                            <div class="node node-unbalanced">30</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div>
                                    <div class="node">10</div>
                                    <div class="edge-right"></div>
                                    <div class="node">20</div>
                                </div>
                                <div class="edge-right"></div>
                                <div class="node">40</div>
                            </div>
                        </div>
                    `,
                    step1: `
                        <div class="tree-container">
                            <div class="node node-unbalanced">30</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div>
                                    <div class="node node-current">10</div>
                                    <div class="edge-right"></div>
                                    <div class="node">20</div>
                                </div>
                                <div class="edge-right"></div>
                                <div class="node">40</div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">检测到LR型失衡，先对左孩子执行左旋转</div>
                        </div>
                    `,
                    step2: `
                        <div class="tree-container">
                            <div class="node node-current node-unbalanced">30</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div>
                                    <div class="node">20</div>
                                    <div class="edge-left"></div>
                                    <div class="node">10</div>
                                </div>
                                <div class="edge-right"></div>
                                <div class="node">40</div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">左旋转完成，再对根节点执行右旋转</div>
                        </div>
                    `,
                    step3: `
                        <div class="tree-container">
                            <div class="node">20</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div class="node">10</div>
                                <div class="edge"></div>
                                <div class="node node-current">30</div>
                                <div class="edge-right"></div>
                                <div class="node">40</div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">左右旋转完成，树恢复平衡</div>
                        </div>
                    `
                },
                'right-left': {
                    initial: `
                        <div class="tree-container">
                            <div class="node node-unbalanced">10</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div class="node">5</div>
                                <div class="edge-left"></div>
                                <div>
                                    <div class="node">30</div>
                                    <div class="edge-left"></div>
                                    <div class="node">20</div>
                                </div>
                            </div>
                        </div>
                    `,
                    step1: `
                        <div class="tree-container">
                            <div class="node node-unbalanced">10</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div class="node">5</div>
                                <div class="edge-left"></div>
                                <div>
                                    <div class="node node-current">30</div>
                                    <div class="edge-left"></div>
                                    <div class="node">20</div>
                                </div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">检测到RL型失衡，先对右孩子执行右旋转</div>
                        </div>
                    `,
                    step2: `
                        <div class="tree-container">
                            <div class="node node-current node-unbalanced">10</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div class="node">5</div>
                                <div class="edge-left"></div>
                                <div>
                                    <div class="node">20</div>
                                    <div class="edge-right"></div>
                                    <div class="node">30</div>
                                </div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">右旋转完成，再对根节点执行左旋转</div>
                        </div>
                    `,
                    step3: `
                        <div class="tree-container">
                            <div class="node">20</div>
                            <div class="edge"></div>
                            <div class="tree-level">
                                <div>
                                    <div class="node node-current">10</div>
                                    <div class="edge-left"></div>
                                    <div class="node">5</div>
                                </div>
                                <div class="edge"></div>
                                <div class="node">30</div>
                            </div>
                            <div class="text-sm mt-2 text-gray-600">右左旋转完成，树恢复平衡</div>
                        </div>
                    `
                }
            };
            
            // 代码行高亮映射
            const codeHighlights = {
                'right': [2, 3, 4, 7, 8, 11, 12, 17],
                'left': [20, 21, 22, 26, 27, 30, 31, 36],
                'left-right': [20, 21, 22, 26, 27, 30, 31, 2, 3, 4, 7, 8, 11, 12, 17],
                'right-left': [2, 3, 4, 7, 8, 11, 12, 17, 20, 21, 22, 26, 27, 30, 31, 36]
            };
            
            // 重置旋转演示
            function resetRotationDemo() {
                // 重置状态
                rotationStatus.textContent = '状态: 等待开始';
                
                // 重置树可视化
                const type = rotationType.value;
                treeVisualization.innerHTML = treeHtmls[type].initial || treeHtmls['right'].initial;
                
                // 重置代码高亮
                for (let i = 1; i <= 37; i++) {
                    const codeLine = document.getElementById(`rotate-code-${i}`);
                    if (codeLine) codeLine.classList.remove('code-line-highlight');
                }
                
                // 重置步骤说明
                updateRotationSteps();
            }
            
            // 更新旋转步骤说明
            function updateRotationSteps() {
                const type = rotationType.value;
                const steps = rotationStepTexts[type] || rotationStepTexts['right'];
                
                rotationSteps.innerHTML = '';
                steps.forEach(stepText => {
                    const li = document.createElement('li');
                    li.textContent = stepText;
                    rotationSteps.appendChild(li);
                });
            }
            
            // 运行旋转动画
            function runRotationAnimation() {
                const type = rotationType.value;
                const steps = treeHtmls[type];
                const codes = codeHighlights[type] || codeHighlights['right'];
                const stepKeys = Object.keys(steps).filter(key => key.startsWith('step'));
                let currentStep = 0;
                
                // 重置代码高亮
                for (let i = 1; i <= 37; i++) {
                    const codeLine = document.getElementById(`rotate-code-${i}`);
                    if (codeLine) codeLine.classList.remove('code-line-highlight');
                }
                
                // 动画步骤函数
                function animateStep() {
                    if (currentStep < stepKeys.length) {
                        const stepKey = stepKeys[currentStep];
                        treeVisualization.innerHTML = steps[stepKey];
                        
                        // 更新状态
                        rotationStatus.textContent = `状态: 执行步骤 ${currentStep + 1}/${stepKeys.length}`;
                        
                        // 高亮当前步骤对应的代码行
                        const codeIndex = Math.min(currentStep, codes.length - 1);
                        const codeLine = document.getElementById(`rotate-code-${codes[codeIndex]}`);
                        if (codeLine) {
                            // 移除上一步的高亮
                            if (currentStep > 0) {
                                const prevCodeLine = document.getElementById(`rotate-code-${codes[codeIndex - 1]}`);
                                if (prevCodeLine) prevCodeLine.classList.remove('code-line-highlight');
                            }
                            codeLine.classList.add('code-line-highlight');
                        }
                        
                        currentStep++;
                        setTimeout(animateStep, 1500);
                    } else {
                        rotationStatus.textContent = '状态: 动画完成';
                        // 高亮最终相关代码
                        codes.forEach(codeNum => {
                            const codeLine = document.getElementById(`rotate-code-${codeNum}`);
                            if (codeLine) codeLine.classList.add('code-line-highlight');
                        });
                    }
                }
                
                // 开始动画
                animateStep();
            }
            
            // 事件监听
            rotationRunBtn.addEventListener('click', runRotationAnimation);
            rotationResetBtn.addEventListener('click', resetRotationDemo);
            rotationType.addEventListener('change', resetRotationDemo);
            
            // 初始化
            resetRotationDemo();
        }
        
        // 插入动画演示初始化
        function initInsertDemo() {
            const insertRunBtn = document.getElementById('insert-run');
            const insertStepBtn = document.getElementById('insert-step');
            const insertResetBtn = document.getElementById('insert-reset');
            const insertValuesInput = document.getElementById('insert-values');
            const insertStatus = document.getElementById('insert-status');
            const insertProgressBar = document.getElementById('insert-progress-bar');
            const insertTreeVisualization = document.getElementById('insert-tree-visualization');
            
            // 显示状态
            insertStatus.classList.remove('hidden');
            
            // 存储当前插入状态
            let insertState = {
                values: [],
                currentIndex: 0,
                steps: [],
                currentStep: 0,
                tree: null
            };
            
            // 代码行高亮映射
            const codeLineMap = {
                'insert': [4, 5, 6],
                'insert-left': [8, 9],
                'insert-right': [10, 11],
                'update-height': [17, 18],
                'check-balance': [21],
                'll-rotate': [25, 26],
                'rr-rotate': [30, 31],
                'lr-rotate': [35, 36, 37],
                'rl-rotate': [41, 42, 43],
                'return': [47]
            };
            
            // 解析输入值
            function parseValues(input) {
                return input.split(',').map(val => parseInt(val.trim())).filter(val => !isNaN(val));
            }
            
            // 重置插入演示
            function resetInsertDemo() {
                // 重置状态
                insertState = {
                    values: parseValues(insertValuesInput.value),
                    currentIndex: 0,
                    steps: [],
                    currentStep: 0,
                    tree: null
                };
                
                insertStatus.textContent = '状态: 等待开始';
                insertProgressBar.style.width = '0%';
                insertTreeVisualization.innerHTML = `
                    <div class="text-center text-gray-500 py-8">
                        <i class="fa fa-tree mb-2 text-2xl"></i>
                        <p>点击"运行插入"或"单步执行"</p>
                    </div>
                `;
                
                // 重置代码高亮
                for (let i = 1; i <= 48; i++) {
                    const codeLine = document.getElementById(`insert-code-${i}`);
                    if (codeLine) codeLine.classList.remove('code-line-highlight');
                }
            }
            
            // 创建节点
            function createNode(key) {
                return {
                    key,
                    height: 1,
                    left: null,
                    right: null,
                    balanceFactor: 0
                };
            }
            
            // 计算节点高度
            function calculateHeight(node) {
                if (!node) return 0;
                return 1 + Math.max(
                    node.left ? node.left.height : 0,
                    node.right ? node.right.height : 0
                );
            }
            
            // 计算平衡因子
            function calculateBalanceFactor(node) {
                if (!node) return 0;
                return (node.left ? node.left.height : 0) - 
                       (node.right ? node.right.height : 0);
            }
            
            // 右旋转
            function rightRotate(y) {
                const x = y.left;
                const T2 = x.right;
                
                x.right = y;
                y.left = T2;
                
                // 更新高度
                y.height = calculateHeight(y);
                x.height = calculateHeight(x);
                
                // 更新平衡因子
                y.balanceFactor = calculateBalanceFactor(y);
                x.balanceFactor = calculateBalanceFactor(x);
                if (T2) T2.balanceFactor = calculateBalanceFactor(T2);
                
                return x;
            }
            
            // 左旋转
            function leftRotate(x) {
                const y = x.right;
                const T2 = y.left;
                
                y.left = x;
                x.right = T2;
                
                // 更新高度
                x.height = calculateHeight(x);
                y.height = calculateHeight(y);
                
                // 更新平衡因子
                x.balanceFactor = calculateBalanceFactor(x);
                y.balanceFactor = calculateBalanceFactor(y);
                if (T2) T2.balanceFactor = calculateBalanceFactor(T2);
                
                return y;
            }
            
            // 插入节点并记录步骤
            function insertNodeAndRecordSteps(root, key) {
                const steps = [];
                
                // 辅助函数：实际插入并记录步骤
                function insertHelper(node, key, path = []) {
                    // 记录当前路径
                    const currentPath = [...path, node];
                    
                    // 1. 标准BST插入
                    if (!node) {
                        const newNode = createNode(key);
                        steps.push({
                            type: 'insert',
                            message: `插入节点 ${key}`,
                            node: newNode
                        });
                        return newNode;
                    }
                    
                    if (key < node.key) {
                        steps.push({
                            type: 'insert-left',
                            message: `节点 ${node.key} 的左子树中插入 ${key}`,
                            node: node
                        });
                        node.left = insertHelper(node.left, key, [...currentPath, 'left']);
                    } else if (key > node.key) {
                        steps.push({
                            type: 'insert-right',
                            message: `节点 ${node.key} 的右子树中插入 ${key}`,
                            node: node
                        });
                        node.right = insertHelper(node.right, key, [...currentPath, 'right']);
                    } else {
                        // 重复值，不插入
                        steps.push({
                            type: 'duplicate',
                            message: `节点 ${key} 已存在，不插入`,
                            node: node
                        });
                        return node;
                    }
                    
                    // 2. 更新高度
                    const oldHeight = node.height;
                    node.height = calculateHeight(node);
                    if (node.height !== oldHeight) {
                        steps.push({
                            type: 'update-height',
                            message: `更新节点 ${node.key} 的高度为 ${node.height}`,
                            node: node
                        });
                    }
                    
                    // 3. 计算平衡因子
                    node.balanceFactor = calculateBalanceFactor(node);
                    steps.push({
                        type: 'check-balance',
                        message: `节点 ${node.key} 的平衡因子为 ${node.balanceFactor}`,
                        node: node
                    });
                    
                    // 4. 如果失衡，进行旋转处理
                    let newNode = node;
                    
                    // LL型：左左情况，右旋转
                    if (node.balanceFactor > 1 && key < node.left.key) {
                        steps.push({
                            type: 'll-rotate',
                            message: `检测到LL型失衡，对节点 ${node.key} 执行右旋转`,
                            node: node
                        });
                        newNode = rightRotate(node);
                        steps.push({
                            type: 'll-rotate',
                            message: `右旋转完成，新根节点为 ${newNode.key}`,
                            node: newNode
                        });
                    }
                    // RR型：右右情况，左旋转
                    else if (node.balanceFactor < -1 && key > node.right.key) {
                        steps.push({
                            type: 'rr-rotate',
                            message: `检测到RR型失衡，对节点 ${node.key} 执行左旋转`,
                            node: node
                        });
                        newNode = leftRotate(node);
                        steps.push({
                            type: 'rr-rotate',
                            message: `左旋转完成，新根节点为 ${newNode.key}`,
                            node: newNode
                        });
                    }
                    // LR型：左右情况，先左旋转再右旋转
                    else if (node.balanceFactor > 1 && key > node.left.key) {
                        steps.push({
                            type: 'lr-rotate',
                            message: `检测到LR型失衡，先对节点 ${node.left.key} 执行左旋转`,
                            node: node.left
                        });
                        node.left = leftRotate(node.left);
                        steps.push({
                            type: 'lr-rotate',
                            message: `再对节点 ${node.key} 执行右旋转`,
                            node: node
                        });
                        newNode = rightRotate(node);
                        steps.push({
                            type: 'lr-rotate',
                            message: `左右旋转完成，新根节点为 ${newNode.key}`,
                            node: newNode
                        });
                    }
                    // RL型：右左情况，先右旋转再左旋转
                    else if (node.balanceFactor < -1 && key < node.right.key) {
                        steps.push({
                            type: 'rl-rotate',
                            message: `检测到RL型失衡，先对节点 ${node.right.key} 执行右旋转`,
                            node: node.right
                        });
                        node.right = rightRotate(node.right);
                        steps.push({
                            type: 'rl-rotate',
                            message: `再对节点 ${node.key} 执行左旋转`,
                            node: node
                        });
                        newNode = leftRotate(node);
                        steps.push({
                            type: 'rl-rotate',
                            message: `右左旋转完成，新根节点为 ${newNode.key}`,
                            node: newNode
                        });
                    }
                    
                    // 5. 返回节点
                    steps.push({
                        type: 'return',
                        message: `返回节点 ${newNode.key}`,
                        node: newNode
                    });
                    
                    return newNode;
                }
                
                const newRoot = insertHelper(root, key);
                return { root: newRoot, steps };
            }
            
            // 渲染树结构
            function renderTree(node) {
                if (!node) {
                    return `
                        <div class="text-center text-gray-500 py-4">
                            <p>空树</p>
                        </div>
                    `;
                }
                
                function renderNode(n, isCurrent = false) {
                    const className = `node ${isCurrent ? 'node-current' : ''} ${
                        Math.abs(n.balanceFactor) > 1 ? 'node-unbalanced' : 'node-balanced'
                    }`;
                    return `
                        <div class="${className}">
                            ${n.key}
                            <div class="text-xs absolute -bottom-5 left-1/2 transform -translate-x-1/2">
                                ${n.balanceFactor}
                            </div>
                        </div>
                    `;
                }
                
                function buildTreeHtml(n, currentNode = null) {
                    if (!n) return '';
                    
                    const isCurrent = currentNode && n.key === currentNode.key;
                    let html = `<div class="tree-node">${renderNode(n, isCurrent)}</div>`;
                    
                    const hasLeft = !!n.left;
                    const hasRight = !!n.right;
                    
                    if (hasLeft || hasRight) {
                        html += `<div class="edge"></div>`;
                        html += `<div class="tree-level">`;
                        
                        if (hasLeft) {
                            html += `<div class="tree-branch left">${buildTreeHtml(n.left, currentNode)}</div>`;
                        } else {
                            html += `<div class="tree-branch empty left"></div>`;
                        }
                        
                        if (hasRight) {
                            html += `<div class="tree-branch right">${buildTreeHtml(n.right, currentNode)}</div>`;
                        } else {
                            html += `<div class="tree-branch empty right"></div>`;
                        }
                        
                        html += `</div>`;
                    }
                    
                    return html;
                }
                
                return `<div class="tree-container">${buildTreeHtml(node, insertState.steps[insertState.currentStep]?.node)}</div>`;
            }
            
            // 执行下一步
            function executeNextStep() {
                if (insertState.currentIndex >= insertState.values.length) {
                    insertStatus.textContent = '状态: 所有插入操作完成';
                    return false;
                }
                
                // 如果是新的插入值，准备步骤
                if (insertState.currentStep >= insertState.steps.length) {
                    const value = insertState.values[insertState.currentIndex];
                    insertStatus.textContent = `状态: 准备插入 ${value}`;
                    
                    // 执行插入并获取步骤
                    const result = insertNodeAndRecordSteps(insertState.tree, value);
                    insertState.tree = result.root;
                    insertState.steps = result.steps;
                    insertState.currentStep = 0;
                }
                
                // 执行当前步骤
                if (insertState.currentStep < insertState.steps.length) {
                    const step = insertState.steps[insertState.currentStep];
                    insertStatus.textContent = `状态: ${step.message}`;
                    
                    // 更新树可视化
                    insertTreeVisualization.innerHTML = renderTree(insertState.tree);
                    
                    // 高亮代码行
                    for (let i = 1; i <= 48; i++) {
                        const codeLine = document.getElementById(`insert-code-${i}`);
                        if (codeLine) codeLine.classList.remove('code-line-highlight');
                    }
                    
                    const lines = codeLineMap[step.type];
                    if (lines) {
                        lines.forEach(lineNum => {
                            const codeLine = document.getElementById(`insert-code-${lineNum}`);
                            if (codeLine) codeLine.classList.add('code-line-highlight');
                        });
                    }
                    
                    insertState.currentStep++;
                    
                    // 如果完成了当前值的所有步骤，移动到下一个值
                    if (insertState.currentStep >= insertState.steps.length) {
                        insertState.currentIndex++;
                        const progress = (insertState.currentIndex / insertState.values.length) * 100;
                        insertProgressBar.style.width = `${progress}%`;
                    }
                    
                    return true;
                }
                
                return false;
            }
            
            // 运行所有步骤
            function runAllSteps() {
                if (!executeNextStep()) return;
                
                if (insertState.currentIndex < insertState.values.length || 
                    insertState.currentStep < insertState.steps.length) {
                    setTimeout(runAllSteps, 1000);
                }
            }
            
            // 事件监听
            insertRunBtn.addEventListener('click', runAllSteps);
            insertStepBtn.addEventListener('click', executeNextStep);
            insertResetBtn.addEventListener('click', resetInsertDemo);
            insertValuesInput.addEventListener('change', resetInsertDemo);
            
            // 初始化
            resetInsertDemo();
        }
    </script>
</body>
</html>