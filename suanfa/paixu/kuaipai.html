<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>快速排序 - 姚老师信奥网</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4A80F0', // 主色调：鲜明的蓝色
                        secondary: '#6C63FF', // 辅助色：紫色
                        syntax: '#FF9800', // 语法部分：橙色
                        algorithm: '#2ECC71', // 算法部分：绿色
                        datastructure: '#9C27B0', // 数据结构部分：深紫色
                        darkbg: '#F8FAFC', // 浅灰白背景
                        cardbg: '#FFFFFF', // 卡片背景
                        hoverbg: '#F0F2F5', // 悬停背景
                        quicksort: '#E91E63', // 快速排序主题色：粉红色
                        execution: '#FFEB3B', // 执行高亮：黄色
                    },
                    fontFamily: {
                        mono: ['Consolas', 'Monaco', 'Courier New', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .hover-scale {
                @apply transition-transform duration-300 hover:scale-[1.02];
            }
            .category-bg {
                @apply bg-gradient-to-r from-primary/5 to-primary/10;
            }
            .subcategory-bg {
                @apply bg-gradient-to-r from-secondary/5 to-secondary/10;
            }
            .quicksort-bg {
                @apply bg-gradient-to-r from-quicksort/5 to-quicksort/10;
            }
            .card-shadow {
                @apply shadow-sm hover:shadow-md transition-shadow duration-300;
            }
            .nav-item {
                @apply text-gray-700 hover:text-primary transition-colors duration-200;
            }
            .topic-card {
                @apply bg-cardbg rounded-lg p-5 card-shadow hover-scale;
            }
            .subtopic-item {
                @apply bg-white rounded-md p-3 border border-gray-100 hover:border-primary/50 transition-all duration-200 cursor-pointer;
            }
            .topic-header {
                @apply text-xl font-bold text-primary mb-4 flex items-center;
            }
            .subtopic-header {
                @apply font-semibold text-secondary mb-3;
            }
            .quicksort-header {
                @apply font-bold text-quicksort mb-3;
            }
            .site-title {
                @apply text-2xl font-bold text-primary tracking-tight;
            }
            .code-block {
                @apply bg-gray-800 text-gray-100 rounded-lg p-4 overflow-x-auto my-4 text-sm font-mono;
            }
            .step-item {
                @apply p-3 rounded-md mb-2 border-l-4 border-quicksort bg-quicksort/5;
            }
            .step-number {
                @apply inline-block w-6 h-6 rounded-full bg-quicksort text-white text-center mr-2 text-xs;
            }
            .array-element {
                @apply inline-block w-10 h-10 rounded-md bg-gray-200 text-center leading-10 mx-1 transition-all duration-300;
            }
            .array-pivot {
                @apply bg-quicksort text-white;
            }
            .array-compared {
                @apply bg-yellow-300;
            }
            .array-sorted {
                @apply bg-green-200;
            }
            .array-partition {
                @apply border-2 border-blue-400;
            }
            .animation-controls {
                @apply flex flex-wrap gap-2 items-center my-4;
            }
            .animation-step {
                @apply bg-gray-100 p-3 rounded-lg mb-4;
            }
            .animation-progress {
                @apply w-full bg-gray-200 rounded-full h-2.5 mb-2;
            }
            .animation-progress-bar {
                @apply bg-quicksort h-2.5 rounded-full transition-all duration-300;
            }
            .animation-status {
                @apply text-sm text-gray-600 my-2 p-2 bg-gray-50 rounded;
            }
            .code-line {
                @apply transition-all duration-300;
            }
            .code-line-highlight {
                @apply bg-execution/30 text-gray-900 font-medium;
            }
        }
    </style>
</head>
<body class="bg-darkbg text-gray-800 font-sans min-h-screen">
    <!-- 顶部导航栏 -->
    <header class="bg-white shadow-sm sticky top-0 z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <i class="fa fa-code text-primary text-3xl"></i>
                <h1 class="site-title">姚老师信奥网</h1>
            </div>
            <div class="hidden md:flex items-center space-x-6">
                <a href="#" class="nav-item">首页</a>
                <a href="#" class="nav-item">课程</a>
                <a href="#" class="nav-item">题库</a>
                <a href="#" class="nav-item">关于我们</a>
            </div>
            <div class="flex items-center space-x-4">
                <!-- 搜索框 -->
                <div class="relative hidden md:block">
                    <input type="text" id="search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-64">
                    <button id="search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                        <i class="fa fa-search"></i>
                    </button>
                </div>
                <div class="md:hidden">
                    <button class="text-gray-700">
                        <i class="fa fa-bars text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
        <!-- 移动端搜索框 -->
        <div class="md:hidden px-4 pb-3">
            <div class="relative">
                <input type="text" id="mobile-search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-full">
                <button id="mobile-search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                    <i class="fa fa-search"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- 面包屑导航 -->
    <div class="bg-white border-b border-gray-200 py-2">
        <div class="container mx-auto px-4">
            <nav class="flex text-sm" aria-label="Breadcrumb">
                <ol class="inline-flex items-center space-x-1 md:space-x-3">
                    <li class="inline-flex items-center">
                        <a href="#" class="text-gray-600 hover:text-primary">
                            <i class="fa fa-home mr-1"></i>首页
                        </a>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary">算法基础</a>
                        </div>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary">排序算法</a>
                        </div>
                    </li>
                    <li aria-current="page">
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <span class="text-quicksort font-medium">快速排序</span>
                        </div>
                    </li>
                </ol>
            </nav>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 页面标题 -->
        <div class="quicksort-bg rounded-lg p-6 mb-8">
            <div class="flex flex-col md:flex-row md:items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-quicksort mb-2">快速排序</h1>
                    <p class="text-gray-700">
                        快速排序是一种高效的排序算法，采用分治法策略，平均时间复杂度为O(n log n)。
                        本页面将详细讲解快速排序的原理、实现方法和优化技巧，帮助NOIP竞赛学生掌握这一重要算法。
                    </p>
                </div>
                <div class="mt-4 md:mt-0">
                    <div class="flex space-x-3">
                        <a href="#concept" class="bg-quicksort hover:bg-quicksort/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-book mr-2"></i> 学习概念
                        </a>
                        <a href="#problems" class="bg-white border border-quicksort text-quicksort hover:bg-quicksort/5 px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-list-alt mr-2"></i> 查看题目
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- 快速排序概述 -->
        <section id="concept" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-quicksort mb-6 flex items-center">
                <i class="fa fa-info-circle mr-2"></i> 快速排序概述
            </h2>
            <div class="space-y-4">
                <div>
                    <h3 class="text-xl font-semibold mb-3">什么是快速排序？</h3>
                    <p class="text-gray-700">
                        快速排序（Quicksort）是由计算机科学家Tony Hoare在1960年提出的一种排序算法。它的基本思想是通过分治法（Divide and Conquer）将一个大数组分为两个较小的子数组，然后递归地排序这两个子数组。
                    </p>
                    <div class="bg-gray-50 p-4 rounded-lg mt-3">
                        <h4 class="font-semibold mb-2">快速排序的核心优势：</h4>
                        <ul class="list-disc pl-5 space-y-2">
                            <li>平均时间复杂度为O(n log n)，实际应用中通常比其他同复杂度算法更快</li>
                            <li>原地排序，不需要额外的大量存储空间</li>
                            <li>缓存友好，具有良好的局部性</li>
                            <li>可以有效处理大量数据</li>
                        </ul>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-3">快速排序的基本步骤</h3>
                    <p class="text-gray-700 mb-3">
                        快速排序算法主要包括以下三个步骤：
                    </p>
                    
                    <div class="space-y-4">
                        <div class="step-item">
                            <div class="flex items-center">
                                <span class="step-number">1</span>
                                <h4 class="font-semibold">选择基准值（Pivot）</h4>
                            </div>
                            <p class="text-gray-700 ml-8">
                                从数组中选择一个元素作为"基准"（pivot），通常可以选择第一个元素、最后一个元素或中间元素。
                            </p>
                        </div>
                        
                        <div class="step-item">
                            <div class="flex items-center">
                                <span class="step-number">2</span>
                                <h4 class="font-semibold">分区（Partition）</h4>
                            </div>
                            <p class="text-gray-700 ml-8">
                                重新排列数组，将所有比基准值小的元素移到基准值前面，所有比基准值大的元素移到基准值后面（相等的元素可以到任一边）。
                                分区结束后，基准值处于数组的中间位置，称为分区操作。
                            </p>
                        </div>
                        
                        <div class="step-item">
                            <div class="flex items-center">
                                <span class="step-number">3</span>
                                <h4 class="font-semibold">递归排序子数组</h4>
                            </div>
                            <p class="text-gray-700 ml-8">
                                递归地将小于基准值的子数组和大于基准值的子数组进行排序。递归的终止条件是子数组的大小为0或1，此时子数组已经有序。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 快速排序动画演示 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-quicksort mb-6 flex items-center">
                <i class="fa fa-play-circle mr-2"></i> 快速排序过程演示
            </h2>
            
            <div class="space-y-6">
                <!-- 排序动画 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">快速排序执行过程可视化</h3>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-1">
                            <p class="text-gray-700 mb-4">
                                下面的动画展示了快速排序的完整过程，包括基准值选择、分区操作和递归排序三个主要步骤。
                            </p>
                            
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">数组元素:</label>
                                <input type="text" id="array-input" value="6,3,8,5,2,7,1,4"
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-quicksort">
                                <p class="text-xs text-gray-500 mt-1">请输入逗号分隔的整数，如: 6,3,8,5,2,7,1,4</p>
                            </div>
                            
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">基准值选择:</label>
                                <div class="flex space-x-2">
                                    <label class="inline-flex items-center">
                                        <input type="radio" name="pivot-select" value="first" class="form-radio text-quicksort" checked>
                                        <span class="ml-2">第一个元素</span>
                                    </label>
                                    <label class="inline-flex items-center">
                                        <input type="radio" name="pivot-select" value="last" class="form-radio text-quicksort">
                                        <span class="ml-2">最后一个元素</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="flex space-x-2">
                                <button id="sort-run" class="bg-quicksort hover:bg-quicksort/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-play mr-2"></i> 开始排序
                                </button>
                                <button id="sort-step" class="bg-white border border-quicksort text-quicksort hover:bg-quicksort/5 px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-step-forward mr-2"></i> 单步执行
                                </button>
                                <button id="sort-reset" class="bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-refresh mr-2"></i> 重置
                                </button>
                            </div>
                            
                            <div id="sort-status" class="animation-status mt-4">
                                状态: 等待开始
                            </div>
                            
                            <div class="animation-progress mt-4">
                                <div id="sort-progress-bar" class="animation-progress-bar" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-white border border-gray-200 rounded-lg p-4 h-64 overflow-y-auto" id="sort-execution">
                                <div class="text-center text-gray-500 py-8">
                                    <i class="fa fa-arrow-down mb-2"></i>
                                    <p>点击"开始排序"观看演示</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-gray-800 text-gray-100 rounded-lg p-4 h-64 overflow-y-auto font-mono text-sm" id="sort-code">
                                <div class="code-line" id="qcode-1">// 快速排序实现</div>
                                <div class="code-line" id="qcode-2">void quickSort(int arr[], int low, int high) {</div>
                                <div class="code-line" id="qcode-3">&nbsp;&nbsp;if (low < high) {</div>
                                <div class="code-line" id="qcode-4">&nbsp;&nbsp;&nbsp;&nbsp;// 分区操作，获取基准值位置</div>
                                <div class="code-line" id="qcode-5">&nbsp;&nbsp;&nbsp;&nbsp;int pi = partition(arr, low, high);</div>
                                <div class="code-line" id="qcode-6">&nbsp;&nbsp;&nbsp;&nbsp;</div>
                                <div class="code-line" id="qcode-7">&nbsp;&nbsp;&nbsp;&nbsp;// 递归排序左半部分</div>
                                <div class="code-line" id="qcode-8">&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr, low, pi - 1);</div>
                                <div class="code-line" id="qcode-9">&nbsp;&nbsp;&nbsp;&nbsp;</div>
                                <div class="code-line" id="qcode-10">&nbsp;&nbsp;&nbsp;&nbsp;// 递归排序右半部分</div>
                                <div class="code-line" id="qcode-11">&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr, pi + 1, high);</div>
                                <div class="code-line" id="qcode-12">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="qcode-13">}</div>
                                <div class="code-line" id="qcode-14">&nbsp;</div>
                                <div class="code-line" id="qcode-15">// 分区函数</div>
                                <div class="code-line" id="qcode-16">int partition(int arr[], int low, int high) {</div>
                                <div class="code-line" id="qcode-17">&nbsp;&nbsp;// 选择基准值</div>
                                <div class="code-line" id="qcode-18">&nbsp;&nbsp;int pivot = arr[low];</div>
                                <div class="code-line" id="qcode-19">&nbsp;&nbsp;int i = low;</div>
                                <div class="code-line" id="qcode-20">&nbsp;&nbsp;</div>
                                <div class="code-line" id="qcode-21">&nbsp;&nbsp;// 遍历数组，将元素放到基准值两侧</div>
                                <div class="code-line" id="qcode-22">&nbsp;&nbsp;for (int j = low + 1; j <= high; j++) {</div>
                                <div class="code-line" id="qcode-23">&nbsp;&nbsp;&nbsp;&nbsp;if (arr[j] <= pivot) {</div>
                                <div class="code-line" id="qcode-24">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;</div>
                                <div class="code-line" id="qcode-25">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(arr[i], arr[j]);</div>
                                <div class="code-line" id="qcode-26">&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="qcode-27">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="qcode-28">&nbsp;&nbsp;</div>
                                <div class="code-line" id="qcode-29">&nbsp;&nbsp;// 将基准值放到正确位置</div>
                                <div class="code-line" id="qcode-30">&nbsp;&nbsp;swap(arr[i], arr[low]);</div>
                                <div class="code-line" id="qcode-31">&nbsp;&nbsp;</div>
                                <div class="code-line" id="qcode-32">&nbsp;&nbsp;// 返回基准值位置</div>
                                <div class="code-line" id="qcode-33">&nbsp;&nbsp;return i;</div>
                                <div class="code-line" id="qcode-34">}</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 数组可视化区域 -->
                    <div class="mt-6">
                        <h4 class="font-semibold mb-3">数组状态：</h4>
                        <div id="array-visualization" class="py-6 flex flex-wrap justify-center items-center">
                            <!-- 数组元素将在这里动态生成 -->
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 快速排序实现 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-quicksort mb-6 flex items-center">
                <i class="fa fa-code mr-2"></i> 快速排序代码实现 (C++)
            </h2>
            
            <div class="space-y-6">
                <!-- 基础实现 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">1. 基础实现</h3>
                    <p class="text-gray-700 mb-3">
                        最基本的快速排序实现，选择第一个元素作为基准值
                    </p>
                    
                    <pre class="code-block"><code class="language-cpp">#include <iostream>
using namespace std;

// 交换两个元素
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// 分区操作
int partition(int arr[], int low, int high) {
    // 选择第一个元素作为基准值
    int pivot = arr[low];
    int i = low;  // i是小于等于基准值区域的边界
    
    // 遍历数组，将小于等于基准值的元素放到左侧
    for (int j = low + 1; j <= high; j++) {
        if (arr[j] <= pivot) {
            i++;  // 扩大小于等于基准值的区域
            swap(arr[i], arr[j]);  // 将当前元素放到该区域
        }
    }
    
    // 将基准值放到正确的位置
    swap(arr[i], arr[low]);
    
    // 返回基准值的位置
    return i;
}

// 快速排序函数
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // 进行分区操作，获取基准值位置
        int pi = partition(arr, low, high);
        
        // 递归排序基准值左侧的子数组
        quickSort(arr, low, pi - 1);
        
        // 递归排序基准值右侧的子数组
        quickSort(arr, pi + 1, high);
    }
}

// 打印数组
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int arr[] = {6, 3, 8, 5, 2, 7, 1, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "排序前的数组: ";
    printArray(arr, n);
    
    quickSort(arr, 0, n - 1);
    
    cout << "排序后的数组: ";
    printArray(arr, n);
    
    return 0;
}</code></pre>
                </div>
                
                <!-- 优化版本 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">2. 优化实现</h3>
                    <p class="text-gray-700 mb-3">
                        针对基础版本的优化：随机选择基准值避免最坏情况，小数组使用插入排序
                    </p>
                    
                    <pre class="code-block"><code class="language-cpp">#include <iostream>
#include <cstdlib>  // 用于rand()函数
#include <ctime>    // 用于时间种子
using namespace std;

// 交换两个元素
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// 插入排序，用于小数组
void insertionSort(int arr[], int low, int high) {
    for (int i = low + 1; i <= high; i++) {
        int key = arr[i];
        int j = i - 1;
        
        // 将大于key的元素向后移动
        while (j >= low && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

// 随机选择基准值并进行分区
int randomPartition(int arr[], int low, int high) {
    // 生成[low, high]范围内的随机索引
    int randomIndex = low + rand() % (high - low + 1);
    
    // 将随机选择的元素与第一个元素交换
    swap(arr[low], arr[randomIndex]);
    
    // 使用基本的分区方法
    int pivot = arr[low];
    int i = low;
    
    for (int j = low + 1; j <= high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    swap(arr[i], arr[low]);
    return i;
}

// 优化的快速排序
void quickSort(int arr[], int low, int high) {
    // 当数组规模较小时，使用插入排序
    if (high - low + 1 <= 10) {
        insertionSort(arr, low, high);
        return;
    }
    
    if (low < high) {
        // 使用随机分区避免最坏情况
        int pi = randomPartition(arr, low, high);
        
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// 打印数组
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    // 设置随机数种子
    srand(time(0));
    
    int arr[] = {6, 3, 8, 5, 2, 7, 1, 4, 10, 9};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "排序前的数组: ";
    printArray(arr, n);
    
    quickSort(arr, 0, n - 1);
    
    cout << "排序后的数组: ";
    printArray(arr, n);
    
    return 0;
}</code></pre>
                </div>
                
                <!-- 非递归实现 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">3. 非递归实现（迭代版本）</h3>
                    <p class="text-gray-700 mb-3">
                        使用栈模拟递归过程，避免递归调用的栈溢出问题
                    </p>
                    
                    <pre class="code-block"><code class="language-cpp">#include <iostream>
#include <stack>  // 使用栈来模拟递归
using namespace std;

// 交换两个元素
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// 分区操作
int partition(int arr[], int low, int high) {
    int pivot = arr[low];
    int i = low;
    
    for (int j = low + 1; j <= high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    swap(arr[i], arr[low]);
    return i;
}

// 非递归的快速排序
void quickSortIterative(int arr[], int low, int high) {
    // 创建一个栈来存储子数组的边界
    stack<int> stack;
    
    // 将整个数组的边界入栈
    stack.push(low);
    stack.push(high);
    
    // 当栈不为空时处理
    while (!stack.empty()) {
        // 弹出高边界和低边界
        high = stack.top();
        stack.pop();
        low = stack.top();
        stack.pop();
        
        // 对当前子数组进行分区
        int pi = partition(arr, low, high);
        
        // 如果左侧子数组有元素，将其边界入栈
        if (pi - 1 > low) {
            stack.push(low);
            stack.push(pi - 1);
        }
        
        // 如果右侧子数组有元素，将其边界入栈
        if (pi + 1 < high) {
            stack.push(pi + 1);
            stack.push(high);
        }
    }
}

// 打印数组
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int arr[] = {6, 3, 8, 5, 2, 7, 1, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    cout << "排序前的数组: ";
    printArray(arr, n);
    
    quickSortIterative(arr, 0, n - 1);
    
    cout << "排序后的数组: ";
    printArray(arr, n);
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- 算法分析 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-quicksort mb-6 flex items-center">
                <i class="fa fa-line-chart mr-2"></i> 快速排序算法分析
            </h2>
            
            <div class="space-y-6">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h3 class="font-semibold text-lg mb-3">时间复杂度</h3>
                        <ul class="space-y-3">
                            <li class="flex items-start">
                                <span class="font-medium mr-2">最佳情况:</span>
                                <span>O(n log n) - 每次分区操作都将数组分为大致相等的两部分</span>
                            </li>
                            <li class="flex items-start">
                                <span class="font-medium mr-2">平均情况:</span>
                                <span>O(n log n) - 大多数实际应用中的表现</span>
                            </li>
                            <li class="flex items-start">
                                <span class="font-medium mr-2">最坏情况:</span>
                                <span>O(n²) - 数组已经有序或逆序，且选择第一个/最后一个元素作为基准值</span>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h3 class="font-semibold text-lg mb-3">空间复杂度</h3>
                        <ul class="space-y-3">
                            <li class="flex items-start">
                                <span class="font-medium mr-2">递归实现:</span>
                                <span>O(log n) - 主要是递归调用栈所占用的空间</span>
                            </li>
                            <li class="flex items-start">
                                <span class="font-medium mr-2">最坏情况:</span>
                                <span>O(n) - 当数组已经有序且选择第一个/最后一个元素作为基准值</span>
                            </li>
                            <li class="flex items-start">
                                <span class="font-medium mr-2">迭代实现:</span>
                                <span>O(log n) - 使用栈存储子数组边界，优化后可控制栈的大小</span>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h3 class="font-semibold text-lg mb-3">稳定性</h3>
                        <p class="mb-3">
                            快速排序是不稳定的排序算法。
                        </p>
                        <p class="text-gray-700 text-sm">
                            不稳定是指排序后，相等元素的相对顺序可能会改变。例如，对于数组[2, 2, 1]，排序后两个2的相对位置可能会交换。
                        </p>
                    </div>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">快速排序优化技巧</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-white p-3 rounded-lg border border-gray-200">
                            <h4 class="font-semibold text-quicksort mb-2">随机选择基准值</h4>
                            <p class="text-gray-700 text-sm">
                                随机选择基准值可以避免在数组已排序或逆序时出现的最坏情况，使算法性能更加稳定。
                            </p>
                        </div>
                        
                        <div class="bg-white p-3 rounded-lg border border-gray-200">
                            <h4 class="font-semibold text-quicksort mb-2">三数取中法</h4>
                            <p class="text-gray-700 text-sm">
                                选择左端、中间、右端三个位置的元素的中值作为基准值，进一步优化基准值选择。
                            </p>
                        </div>
                        
                        <div class="bg-white p-3 rounded-lg border border-gray-200">
                            <h4 class="font-semibold text-quicksort mb-2">小数组使用插入排序</h4>
                            <p class="text-gray-700 text-sm">
                                当子数组规模小于一定阈值（通常10-20）时，使用插入排序，因为插入排序在小数组上效率更高。
                            </p>
                        </div>
                        
                        <div class="bg-white p-3 rounded-lg border border-gray-200">
                            <h4 class="font-semibold text-quicksort mb-2">尾递归优化</h4>
                            <p class="text-gray-700 text-sm">
                                对较大的子数组使用循环处理，较小的子数组使用递归，减少递归调用深度，降低栈溢出风险。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 推荐题目 -->
        <section id="problems" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-quicksort mb-6 flex items-center">
                <i class="fa fa-tasks mr-2"></i> 推荐练习题目 (洛谷)
            </h2>
            
            <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">模板题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1177 【模板】快速排序</h4>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">入门</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                给定N个整数，使用快速排序算法将它们从小到大排序并输出。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1177" target="_blank" class="text-quicksort hover:text-quicksort/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1923 【深基9.例4】求第k小的数</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                利用快速排序的思想，找出数组中第k小的数，不需要完整排序数组。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1923" target="_blank" class="text-quicksort hover:text-quicksort/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">入门题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1093 奖学金</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                根据学生的成绩进行排序，总分高的在前，总分相同则语文高的在前。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1093" target="_blank" class="text-quicksort hover:text-quicksort/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1781 宇宙总统</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                对大整数进行排序，找出得票最多的总统候选人。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1781" target="_blank" class="text-quicksort hover:text-quicksort/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1068 分数线划定</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                根据考试成绩排序，确定录取分数线并输出录取名单。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1068" target="_blank" class="text-quicksort hover:text-quicksort/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">进阶题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1138 第k小整数</h4>
                                <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">普及/提高-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                从一系列整数中去除重复元素后，找出第k小的数。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1138" target="_blank" class="text-quicksort hover:text-quicksort/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P2234 营业额统计</h4>
                                <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">普及/提高-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                每天的营业额与之前的某个营业额差值最小，使用排序和二分查找高效解决。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P2234" target="_blank" class="text-quicksort hover:text-quicksort/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1908 逆序对</h4>
                                <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">普及/提高-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                利用快速排序的思想统计数组中的逆序对数量，是分治算法的经典应用。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1908" target="_blank" class="text-quicksort hover:text-quicksort/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        // 初始化代码高亮
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
            initQuickSortDemo();
        });

        // 快速排序演示相关功能
        function initQuickSortDemo() {
            // 获取DOM元素
            const arrayInput = document.getElementById('array-input');
            const sortRunBtn = document.getElementById('sort-run');
            const sortStepBtn = document.getElementById('sort-step');
            const sortResetBtn = document.getElementById('sort-reset');
            const sortStatus = document.getElementById('sort-status');
            const sortProgressBar = document.getElementById('sort-progress-bar');
            const sortExecution = document.getElementById('sort-execution');
            const arrayVisualization = document.getElementById('array-visualization');
            const codeLines = [];
            for (let i = 1; i <= 34; i++) {
                codeLines.push(document.getElementById(`qcode-${i}`));
            }

            // 排序演示状态
            let demoState = {
                originalArray: [],
                currentArray: [],
                steps: [],
                currentStep: 0,
                isRunning: false,
                animationSpeed: 800,
                timer: null
            };

            // 初始化数组显示
            function initArrayDisplay() {
                arrayVisualization.innerHTML = '';
                demoState.currentArray.forEach((num, index) => {
                    const elem = document.createElement('div');
                    elem.className = 'array-element';
                    elem.textContent = num;
                    elem.dataset.index = index;
                    arrayVisualization.appendChild(elem);
                });
            }

            // 解析输入的数组
            function parseArrayInput() {
                const input = arrayInput.value.trim();
                if (!input) return [6, 3, 8, 5, 2, 7, 1, 4];
                
                try {
                    return input.split(',').map(num => parseInt(num.trim())).filter(num => !isNaN(num));
                } catch (e) {
                    return [6, 3, 8, 5, 2, 7, 1, 4];
                }
            }

            // 重置演示
            function resetDemo() {
                // 清除定时器
                if (demoState.timer) {
                    clearInterval(demoState.timer);
                    demoState.timer = null;
                }
                
                // 重置状态
                demoState.originalArray = parseArrayInput();
                demoState.currentArray = [...demoState.originalArray];
                demoState.steps = [];
                demoState.currentStep = 0;
                demoState.isRunning = false;
                
                // 生成排序步骤
                generateQuickSortSteps();
                
                // 更新UI
                initArrayDisplay();
                sortStatus.textContent = '状态: 已重置，等待开始';
                sortProgressBar.style.width = '0%';
                sortExecution.innerHTML = '<div class="text-center text-gray-500 py-8"><i class="fa fa-arrow-down mb-2"></i><p>点击"开始排序"观看演示</p></div>';
                
                // 重置代码高亮
                codeLines.forEach(line => line.classList.remove('code-line-highlight'));
            }

            // 记录步骤
            function recordStep(description, codeLineIndices, pivotIndex = -1, comparedIndices = [], sortedIndices = [], partitionIndices = []) {
                demoState.steps.push({
                    description,
                    codeLineIndices,
                    pivotIndex,
                    comparedIndices,
                    sortedIndices,
                    partitionIndices,
                    arrayState: [...demoState.currentArray]
                });
            }

            // 生成快速排序步骤
            function generateQuickSortSteps() {
                // 重置步骤
                demoState.steps = [];
                demoState.currentArray = [...demoState.originalArray];
                
                // 记录初始状态
                recordStep('初始数组', []);
                
                // 调用模拟快速排序的函数，记录每一步
                const pivotType = document.querySelector('input[name="pivot-select"]:checked').value;
                simulateQuickSort(0, demoState.currentArray.length - 1, pivotType);
            }

            // 模拟分区操作并记录步骤
            function simulatePartition(low, high, pivotType) {
                let pivotIndex;
                
                // 根据选择的基准值类型确定基准值索引
                if (pivotType === 'last') {
                    pivotIndex = high;
                } else { // 'first'
                    pivotIndex = low;
                }
                
                // 记录选择基准值
                recordStep(`选择基准值: ${demoState.currentArray[pivotIndex]} (索引 ${pivotIndex})`, [18], pivotIndex);
                
                // 如果选择的是最后一个元素作为基准值，先交换到第一个位置
                if (pivotType === 'last' && pivotIndex !== low) {
                    [demoState.currentArray[low], demoState.currentArray[pivotIndex]] = 
                    [demoState.currentArray[pivotIndex], demoState.currentArray[low]];
                    pivotIndex = low;
                    recordStep(`将基准值交换到位置 ${low}`, [18], pivotIndex);
                }
                
                const pivot = demoState.currentArray[pivotIndex];
                let i = low;
                
                recordStep(`初始化i = ${i}`, [19]);
                
                // 遍历数组
                for (let j = low + 1; j <= high; j++) {
                    recordStep(`比较 arr[${j}] = ${demoState.currentArray[j]} 与基准值 ${pivot}`, [22, 23], pivotIndex, [j]);
                    
                    if (demoState.currentArray[j] <= pivot) {
                        recordStep(`arr[${j}] <= 基准值，i自增为 ${i + 1}`, [24], pivotIndex, [j]);
                        i++;
                        
                        if (i !== j) {
                            // 交换元素
                            [demoState.currentArray[i], demoState.currentArray[j]] = 
                            [demoState.currentArray[j], demoState.currentArray[i]];
                            recordStep(`交换 arr[${i}] 和 arr[${j}]`, [25], pivotIndex, [i, j]);
                        } else {
                            recordStep(`i与j相等，无需交换`, [25], pivotIndex, [i]);
                        }
                    } else {
                        recordStep(`arr[${j}] > 基准值，不做操作`, [23], pivotIndex, [j]);
                    }
                }
                
                recordStep(`分区完成，准备将基准值放到最终位置`, [29], pivotIndex);
                
                // 将基准值放到正确的位置
                [demoState.currentArray[i], demoState.currentArray[low]] = 
                [demoState.currentArray[low], demoState.currentArray[i]];
                
                recordStep(`将基准值放到位置 ${i}，分区完成`, [30], i);
                
                // 标记已排好序的基准值
                const sortedIndices = [i];
                recordStep(`基准值 ${pivot} 已处于正确位置`, [], -1, [], sortedIndices);
                
                return i;
            }

            // 模拟快速排序并记录步骤
            function simulateQuickSort(low, high, pivotType) {
                if (low >= high) {
                    if (low === high) {
                        recordStep(`单个元素 arr[${low}] = ${demoState.currentArray[low]} 已排序`, [], -1, [], [low]);
                    }
                    return;
                }
                
                recordStep(`开始排序子数组 arr[${low}...${high}]`, [2, 3]);
                
                // 分区操作
                recordStep(`调用分区函数处理 arr[${low}...${high}]`, [5], -1, [], [], [low, high]);
                const pi = simulatePartition(low, high, pivotType);
                
                // 递归排序左半部分
                recordStep(`递归排序左子数组 arr[${low}...${pi - 1}]`, [8], -1, [], [], [low, pi - 1]);
                simulateQuickSort(low, pi - 1, pivotType);
                
                // 递归排序右半部分
                recordStep(`递归排序右子数组 arr[${pi + 1}...${high}]`, [11], -1, [], [], [pi + 1, high]);
                simulateQuickSort(pi + 1, high, pivotType);
                
                recordStep(`子数组 arr[${low}...${high}] 排序完成`, [2], -1, [], Array.from({length: high - low + 1}, (_, i) => low + i));
            }

            // 执行一步
            function executeStep() {
                if (demoState.currentStep >= demoState.steps.length) {
                    // 排序完成
                    sortStatus.textContent = '状态: 排序完成';
                    demoState.isRunning = false;
                    if (demoState.timer) {
                        clearInterval(demoState.timer);
                        demoState.timer = null;
                    }
                    return false;
                }
                
                // 获取当前步骤
                const step = demoState.steps[demoState.currentStep];
                
                // 更新数组状态
                demoState.currentArray = [...step.arrayState];
                
                // 更新数组显示
                const elements = arrayVisualization.getElementsByClassName('array-element');
                Array.from(elements).forEach((elem, index) => {
                    // 重置所有样式
                    elem.className = 'array-element';
                    
                    // 应用当前步骤的样式
                    if (step.pivotIndex === index) {
                        elem.classList.add('array-pivot');
                    } else if (step.comparedIndices.includes(index)) {
                        elem.classList.add('array-compared');
                    } else if (step.sortedIndices.includes(index)) {
                        elem.classList.add('array-sorted');
                    }
                    
                    // 更新值
                    elem.textContent = demoState.currentArray[index];
                });
                
                // 高亮分区范围
                if (step.partitionIndices.length === 2) {
                    const [start, end] = step.partitionIndices;
                    if (start <= end) {
                        for (let i = start; i <= end; i++) {
                            if (elements[i]) {
                                elements[i].classList.add('array-partition');
                            }
                        }
                    }
                }
                
                // 更新代码高亮
                codeLines.forEach(line => line.classList.remove('code-line-highlight'));
                step.codeLineIndices.forEach(idx => {
                    if (codeLines[idx - 1]) {
                        codeLines[idx - 1].classList.add('code-line-highlight');
                    }
                });
                
                // 更新状态和进度
                sortStatus.textContent = `状态: ${step.description}`;
                
                // 添加步骤描述到执行日志
                const stepElem = document.createElement('div');
                stepElem.className = 'mb-2 p-2 bg-gray-50 rounded';
                stepElem.innerHTML = `<span class="font-medium">步骤 ${demoState.currentStep + 1}:</span> ${step.description}`;
                sortExecution.appendChild(stepElem);
                sortExecution.scrollTop = sortExecution.scrollHeight;
                
                // 更新进度条
                const progress = (demoState.currentStep / (demoState.steps.length - 1)) * 100;
                sortProgressBar.style.width = `${progress}%`;
                
                // 进入下一步
                demoState.currentStep++;
                return true;
            }

            // 自动执行所有步骤
            function autoExecute() {
                if (demoState.isRunning) return;
                
                demoState.isRunning = true;
                sortStatus.textContent = '状态: 正在排序...';
                
                // 清除可能存在的定时器
                if (demoState.timer) {
                    clearInterval(demoState.timer);
                }
                
                // 设置定时器执行步骤
                demoState.timer = setInterval(() => {
                    if (!executeStep()) {
                        demoState.isRunning = false;
                    }
                }, demoState.animationSpeed);
            }

            // 事件监听
            sortRunBtn.addEventListener('click', autoExecute);
            
            sortStepBtn.addEventListener('click', () => {
                // 如果正在自动执行，先停止
                if (demoState.isRunning) {
                    clearInterval(demoState.timer);
                    demoState.timer = null;
                    demoState.isRunning = false;
                    sortStatus.textContent = '状态: 手动单步执行';
                }
                executeStep();
            });
            
            sortResetBtn.addEventListener('click', resetDemo);
            
            // 监听基准值选择变化
            document.querySelectorAll('input[name="pivot-select"]').forEach(radio => {
                radio.addEventListener('change', resetDemo);
            });
            
            // 初始化演示
            resetDemo();
        }
    </script>
</body>
</html>