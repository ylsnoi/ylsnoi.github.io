<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>归并排序 - 姚老师信奥网</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4A80F0', // 主色调：鲜明的蓝色
                        secondary: '#6C63FF', // 辅助色：紫色
                        syntax: '#FF9800', // 语法部分：橙色
                        algorithm: '#2ECC71', // 算法部分：绿色
                        datastructure: '#9C27B0', // 数据结构部分：深紫色
                        darkbg: '#F8FAFC', // 浅灰白背景
                        cardbg: '#FFFFFF', // 卡片背景
                        hoverbg: '#F0F2F5', // 悬停背景
                        merge: '#E91E63', // 归并排序主题色：粉红色
                        execution: '#FFEB3B', // 执行高亮：黄色
                    },
                    fontFamily: {
                        mono: ['Consolas', 'Monaco', 'Courier New', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .hover-scale {
                @apply transition-transform duration-300 hover:scale-[1.02];
            }
            .category-bg {
                @apply bg-gradient-to-r from-primary/5 to-primary/10;
            }
            .subcategory-bg {
                @apply bg-gradient-to-r from-secondary/5 to-secondary/10;
            }
            .merge-bg {
                @apply bg-gradient-to-r from-merge/5 to-merge/10;
            }
            .card-shadow {
                @apply shadow-sm hover:shadow-md transition-shadow duration-300;
            }
            .nav-item {
                @apply text-gray-700 hover:text-primary transition-colors duration-200;
            }
            .topic-card {
                @apply bg-cardbg rounded-lg p-5 card-shadow hover-scale;
            }
            .subtopic-item {
                @apply bg-white rounded-md p-3 border border-gray-100 hover:border-primary/50 transition-all duration-200 cursor-pointer;
            }
            .topic-header {
                @apply text-xl font-bold text-primary mb-4 flex items-center;
            }
            .subtopic-header {
                @apply font-semibold text-secondary mb-3;
            }
            .merge-header {
                @apply font-bold text-merge mb-3;
            }
            .site-title {
                @apply text-2xl font-bold text-primary tracking-tight;
            }
            .code-block {
                @apply bg-gray-800 text-gray-100 rounded-lg p-4 overflow-x-auto my-4 text-sm font-mono;
            }
            .step-item {
                @apply p-3 rounded-md mb-2 border-l-4 border-merge bg-merge/5;
            }
            .step-number {
                @apply inline-block w-6 h-6 rounded-full bg-merge text-white text-center mr-2 text-xs;
            }
            .array-element {
                @apply inline-block w-10 h-10 flex items-center justify-center rounded-md bg-gray-200 mr-2 transition-all duration-300;
            }
            .array-element-active {
                @apply bg-merge text-white scale-110;
            }
            .array-element-merged {
                @apply bg-algorithm text-white;
            }
            .array-container {
                @apply my-4 p-4 bg-gray-50 rounded-lg min-h-[80px];
            }
            .merge-section {
                @apply flex flex-col md:flex-row gap-4 my-6;
            }
            .merge-left, .merge-right {
                @apply flex-1 p-3 border border-gray-200 rounded-lg;
            }
            .merge-result {
                @apply p-3 border-2 border-algorithm rounded-lg bg-algorithm/5;
            }
            .animation-controls {
                @apply flex flex-wrap gap-2 items-center my-4;
            }
            .animation-step {
                @apply bg-gray-100 p-3 rounded-lg mb-4;
            }
            .animation-progress {
                @apply w-full bg-gray-200 rounded-full h-2.5 mb-2;
            }
            .animation-progress-bar {
                @apply bg-merge h-2.5 rounded-full transition-all duration-300;
            }
            .animation-status {
                @apply text-sm text-gray-600 my-2 p-2 bg-gray-50 rounded;
            }
            .code-line {
                @apply transition-all duration-300;
            }
            .code-line-highlight {
                @apply bg-execution/30 text-gray-900 font-medium;
            }
        }
    </style>
</head>
<body class="bg-darkbg text-gray-800 font-sans min-h-screen">
    <!-- 顶部导航栏 -->
    <header class="bg-white shadow-sm sticky top-0 z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <i class="fa fa-code text-primary text-3xl"></i>
                <h1 class="site-title">姚老师信奥网</h1>
            </div>
            <div class="hidden md:flex items-center space-x-6">
                <a href="#" class="nav-item">首页</a>
                <a href="#" class="nav-item">课程</a>
                <a href="#" class="nav-item">题库</a>
                <a href="#" class="nav-item">关于我们</a>
            </div>
            <div class="flex items-center space-x-4">
                <!-- 搜索框 -->
                <div class="relative hidden md:block">
                    <input type="text" id="search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-64">
                    <button id="search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                        <i class="fa fa-search"></i>
                    </button>
                </div>
                <div class="md:hidden">
                    <button class="text-gray-700">
                        <i class="fa fa-bars text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
        <!-- 移动端搜索框 -->
        <div class="md:hidden px-4 pb-3">
            <div class="relative">
                <input type="text" id="mobile-search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-full">
                <button id="mobile-search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                    <i class="fa fa-search"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- 面包屑导航 -->
    <div class="bg-white border-b border-gray-200 py-2">
        <div class="container mx-auto px-4">
            <nav class="flex text-sm" aria-label="Breadcrumb">
                <ol class="inline-flex items-center space-x-1 md:space-x-3">
                    <li class="inline-flex items-center">
                        <a href="#" class="text-gray-600 hover:text-primary">
                            <i class="fa fa-home mr-1"></i>首页
                        </a>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary">算法基础</a>
                        </div>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary">排序算法</a>
                        </div>
                    </li>
                    <li aria-current="page">
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <span class="text-merge font-medium">归并排序</span>
                        </div>
                    </li>
                </ol>
            </nav>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 页面标题 -->
        <div class="merge-bg rounded-lg p-6 mb-8">
            <div class="flex flex-col md:flex-row md:items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-merge mb-2">归并排序 (Merge Sort)</h1>
                    <p class="text-gray-700">
                        归并排序是一种基于分治法的高效排序算法，时间复杂度为O(n log n)。本页面将详细讲解归并排序的原理、实现方法和时间复杂度分析，
                        帮助NOIP竞赛学生掌握这一重要排序算法。
                    </p>
                </div>
                <div class="mt-4 md:mt-0">
                    <div class="flex space-x-3">
                        <a href="#concept" class="bg-merge hover:bg-merge/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-book mr-2"></i> 学习概念
                        </a>
                        <a href="#problems" class="bg-white border border-merge text-merge hover:bg-merge/5 px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-list-alt mr-2"></i> 查看题目
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- 归并排序概述 -->
        <section id="concept" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-merge mb-6 flex items-center">
                <i class="fa fa-info-circle mr-2"></i> 归并排序概述
            </h2>
            <div class="space-y-4">
                <div>
                    <h3 class="text-xl font-semibold mb-3">什么是归并排序？</h3>
                    <p class="text-gray-700">
                        归并排序是一种分治策略的排序算法，由约翰·冯·诺依曼于1945年提出。它的核心思想是将待排序数组不断二分，直到每个子数组只包含一个元素，
                        然后将这些有序的子数组两两合并，最终得到一个完全有序的数组。
                    </p>
                    <div class="bg-gray-50 p-4 rounded-lg mt-3">
                        <h4 class="font-semibold mb-2">归并排序的主要特点：</h4>
                        <ul class="list-disc pl-5 space-y-2">
                            <li>时间复杂度稳定为O(n log n)，不受输入数据影响</li>
                            <li>需要额外的O(n)空间</li>
                            <li>是稳定的排序算法（相等元素的相对顺序保持不变）</li>
                            <li>适合处理大型数据和链表排序</li>
                            <li>可并行化程度高</li>
                        </ul>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-3">归并排序的基本步骤</h3>
                    <div class="space-y-3">
                        <div class="step-item">
                            <span class="step-number">1</span>
                            <strong>分解</strong>：将待排序数组递归地分成两个规模大致相等的子数组，直到每个子数组只包含一个元素
                        </div>
                        <div class="step-item">
                            <span class="step-number">2</span>
                            <strong>合并</strong>：将两个已排序的子数组合并成一个更大的有序数组
                        </div>
                        <div class="step-item">
                            <span class="step-number">3</span>
                            <strong>递归</strong>：重复上述过程，直到所有子数组合并成一个完整的有序数组
                        </div>
                    </div>
                    
                    <div class="mt-6">
                        <h4 class="font-semibold mb-3">归并排序的分治策略图示</h4>
                        <div class="bg-white p-4 rounded-lg border border-gray-200">
                            <div class="flex flex-col items-center">
                                <div class="flex items-center mb-2">
                                    <div class="array-element">38</div>
                                    <div class="array-element">27</div>
                                    <div class="array-element">43</div>
                                    <div class="array-element">3</div>
                                    <div class="array-element">9</div>
                                    <div class="array-element">82</div>
                                    <div class="array-element">10</div>
                                    <span class="mx-2">→</span>
                                </div>
                                <div class="flex items-center my-2">
                                    <div class="mr-4">
                                        <div class="array-element">38</div>
                                        <div class="array-element">27</div>
                                        <div class="array-element">43</div>
                                        <div class="array-element">3</div>
                                    </div>
                                    <div>
                                        <div class="array-element">9</div>
                                        <div class="array-element">82</div>
                                        <div class="array-element">10</div>
                                    </div>
                                    <span class="mx-2">→</span>
                                </div>
                                <div class="flex items-center my-2">
                                    <div class="mr-4">
                                        <div class="array-element">38</div>
                                        <div class="array-element">27</div>
                                    </div>
                                    <div class="mr-4">
                                        <div class="array-element">43</div>
                                        <div class="array-element">3</div>
                                    </div>
                                    <div class="mr-4">
                                        <div class="array-element">9</div>
                                        <div class="array-element">82</div>
                                    </div>
                                    <div>
                                        <div class="array-element">10</div>
                                    </div>
                                    <span class="mx-2">→</span>
                                </div>
                                <div class="flex items-center my-2">
                                    <div class="mr-2"><div class="array-element">38</div></div>
                                    <div class="mr-2"><div class="array-element">27</div></div>
                                    <div class="mr-2"><div class="array-element">43</div></div>
                                    <div class="mr-2"><div class="array-element">3</div></div>
                                    <div class="mr-2"><div class="array-element">9</div></div>
                                    <div class="mr-2"><div class="array-element">82</div></div>
                                    <div><div class="array-element">10</div></div>
                                    <span class="mx-2">→</span>
                                </div>
                                <div class="flex items-center my-2">
                                    <div class="mr-4">
                                        <div class="array-element array-element-merged">27</div>
                                        <div class="array-element array-element-merged">38</div>
                                    </div>
                                    <div class="mr-4">
                                        <div class="array-element array-element-merged">3</div>
                                        <div class="array-element array-element-merged">43</div>
                                    </div>
                                    <div class="mr-4">
                                        <div class="array-element array-element-merged">9</div>
                                        <div class="array-element array-element-merged">82</div>
                                    </div>
                                    <div>
                                        <div class="array-element">10</div>
                                    </div>
                                    <span class="mx-2">→</span>
                                </div>
                                <div class="flex items-center my-2">
                                    <div class="mr-4">
                                        <div class="array-element array-element-merged">3</div>
                                        <div class="array-element array-element-merged">27</div>
                                        <div class="array-element array-element-merged">38</div>
                                        <div class="array-element array-element-merged">43</div>
                                    </div>
                                    <div>
                                        <div class="array-element array-element-merged">9</div>
                                        <div class="array-element array-element-merged">10</div>
                                        <div class="array-element array-element-merged">82</div>
                                    </div>
                                    <span class="mx-2">→</span>
                                </div>
                                <div class="flex items-center mt-2">
                                    <div class="array-element array-element-merged">3</div>
                                    <div class="array-element array-element-merged">9</div>
                                    <div class="array-element array-element-merged">10</div>
                                    <div class="array-element array-element-merged">27</div>
                                    <div class="array-element array-element-merged">38</div>
                                    <div class="array-element array-element-merged">43</div>
                                    <div class="array-element array-element-merged">82</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 归并排序动画演示 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-merge mb-6 flex items-center">
                <i class="fa fa-play-circle mr-2"></i> 归并排序过程演示
            </h2>
            
            <div class="space-y-6">
                <!-- 归并排序动画 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">归并排序完整过程演示</h3>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-1">
                            <p class="text-gray-700 mb-4">
                                下面的动画展示了归并排序的完整过程，包括数组分解和合并两个主要阶段。
                                可以通过输入框自定义数组，或使用随机数组进行演示。
                            </p>
                            
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">输入数组元素(用逗号分隔):</label>
                                <input type="text" id="array-input" value="38,27,43,3,9,82,10"
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-merge">
                            </div>
                            
                            <div class="flex space-x-2 mb-4">
                                <button id="random-array" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-random mr-2"></i> 随机数组
                                </button>
                                <button id="reset-array" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-refresh mr-2"></i> 重置
                                </button>
                            </div>
                            
                            <div class="flex space-x-2 mb-4">
                                <button id="merge-start" class="bg-merge hover:bg-merge/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-play mr-2"></i> 开始演示
                                </button>
                                <button id="merge-step" class="bg-white border border-merge text-merge hover:bg-merge/5 px-4 py-2 rounded-md transition-all flex items-center" disabled>
                                    <i class="fa fa-step-forward mr-2"></i> 单步执行
                                </button>
                            </div>
                            
                            <div class="animation-progress">
                                <div id="merge-progress-bar" class="animation-progress-bar" style="width: 0%"></div>
                            </div>
                            
                            <div id="merge-status" class="animation-status">
                                状态: 等待开始
                            </div>
                        </div>
                        
                        <div class="lg:col-span-2">
                            <div class="bg-white border border-gray-200 rounded-lg p-4 mb-4" id="merge-visualization">
                                <div class="text-center text-gray-500 py-8">
                                    <i class="fa fa-arrow-down mb-2"></i>
                                    <p>点击"开始演示"观看归并排序过程</p>
                                </div>
                            </div>
                            
                            <div class="bg-white border border-gray-200 rounded-lg p-4" id="merge-steps">
                                <h4 class="font-semibold mb-2">归并步骤说明</h4>
                                <div id="merge-step-description" class="text-gray-700">
                                    准备开始归并排序演示...
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 归并操作单独演示 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">合并操作演示</h3>
                    <p class="text-gray-700 mb-4">
                        合并操作是归并排序的核心，下面演示如何将两个有序数组合并成一个有序数组
                    </p>
                    
                    <div class="merge-section">
                        <div class="merge-left">
                            <h4 class="font-semibold mb-2">左数组</h4>
                            <div id="left-array" class="array-container">
                                <div class="array-element">3</div>
                                <div class="array-element">27</div>
                                <div class="array-element">38</div>
                                <div class="array-element">43</div>
                            </div>
                        </div>
                        <div class="merge-right">
                            <h4 class="font-semibold mb-2">右数组</h4>
                            <div id="right-array" class="array-container">
                                <div class="array-element">9</div>
                                <div class="array-element">10</div>
                                <div class="array-element">82</div>
                            </div>
                        </div>
                        <div class="merge-result">
                            <h4 class="font-semibold mb-2">合并结果</h4>
                            <div id="merged-array" class="array-container">
                                <div class="array-element">3</div>
                                <div class="array-element">9</div>
                                <div class="array-element">10</div>
                                <div class="array-element">27</div>
                                <div class="array-element">38</div>
                                <div class="array-element">43</div>
                                <div class="array-element">82</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex justify-center">
                        <button id="merge-demo" class="bg-algorithm hover:bg-algorithm/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-random mr-2"></i> 演示合并过程
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- 归并排序代码实现 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-merge mb-6 flex items-center">
                <i class="fa fa-code mr-2"></i> 归并排序代码实现 (C++)
            </h2>
            
            <div class="space-y-6">
                <!-- 递归实现 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">1. 递归实现</h3>
                    <p class="text-gray-700 mb-3">
                        归并排序的标准实现方式，使用递归进行分治操作
                    </p>
                    
                    <pre class="code-block"><code class="language-cpp" id="merge-code">// 归并排序 - 递归实现
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// 将两个有序数组合并
void merge(vector&lt;int&gt;& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左子数组长度
    int n2 = right - mid;     // 右子数组长度
    
    // 创建临时数组
    vector&lt;int&gt; L(n1), R(n2);
    
    // 复制数据到临时数组
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
    
    // 合并临时数组到原数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    // 复制剩余元素
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 归并排序主函数
void mergeSort(vector&lt;int&gt;& arr, int left, int right) {
    if (left < right) {
        // 计算中间位置
        int mid = left + (right - left) / 2;
        
        // 递归排序左半部分
        mergeSort(arr, left, mid);
        // 递归排序右半部分
        mergeSort(arr, mid + 1, right);
        
        // 合并两个有序部分
        merge(arr, left, mid, right);
    }
}

// 打印数组
void printArray(const vector&lt;int&gt;& arr) {
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
}

int main() {
    vector&lt;int&gt; arr = {38, 27, 43, 3, 9, 82, 10};
    cout << "原始数组: ";
    printArray(arr);
    
    mergeSort(arr, 0, arr.size() - 1);
    
    cout << "排序后数组: ";
    printArray(arr);
    
    return 0;
}</code></pre>

                    <div class="mt-4">
                        <button id="run-code" class="bg-merge hover:bg-merge/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-play mr-2"></i> 运行代码并高亮执行过程
                        </button>
                    </div>
                </div>
                
                <!-- 迭代实现 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">2. 迭代实现（非递归）</h3>
                    <p class="text-gray-700 mb-3">
                        归并排序的非递归实现，避免递归调用开销，适合处理大数据
                    </p>
                    
                    <pre class="code-block"><code class="language-cpp">// 归并排序 - 迭代实现
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// 将两个有序数组合并
void merge(vector&lt;int&gt;& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    vector&lt;int&gt; L(n1), R(n2);
    
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
    
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 归并排序迭代实现
void mergeSort(vector&lt;int&gt;& arr) {
    int n = arr.size();
    
    // 子数组长度从1开始，每次翻倍
    for (int size = 1; size < n; size *= 2) {
        // 遍历所有子数组
        for (int left = 0; left < n - 1; left += 2 * size) {
            // 计算中间位置和右边界
            int mid = min(left + size - 1, n - 1);
            int right = min(left + 2 * size - 1, n - 1);
            
            // 合并子数组
            merge(arr, left, mid, right);
        }
    }
}

// 打印数组
void printArray(const vector&lt;int&gt;& arr) {
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
}

int main() {
    vector&lt;int&gt; arr = {38, 27, 43, 3, 9, 82, 10};
    cout << "原始数组: ";
    printArray(arr);
    
    mergeSort(arr);
    
    cout << "排序后数组: ";
    printArray(arr);
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- 时间复杂度分析 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-merge mb-6 flex items-center">
                <i class="fa fa-clock-o mr-2"></i> 时间复杂度分析
            </h2>
            
            <div class="space-y-6">
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">归并排序的时间复杂度</h3>
                    <p class="text-gray-700 mb-4">
                        归并排序的时间复杂度分析可以通过递归树或递推公式来进行：
                    </p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold text-merge mb-2">递归树分析</h4>
                            <ul class="list-disc pl-5 space-y-2 text-gray-700">
                                <li>归并排序将问题分解为两个规模为n/2的子问题</li>
                                <li>分解过程形成深度为log₂n的递归树</li>
                                <li>每一层的合并操作总时间复杂度为O(n)</li>
                                <li>总时间复杂度 = 层数 × 每层操作 = O(n log n)</li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="font-semibold text-merge mb-2">递推公式分析</h4>
                            <p class="text-gray-700 mb-2">归并排序的时间复杂度递推公式：</p>
                            <div class="bg-white p-3 rounded-lg text-center mb-2">
                                T(n) = 2T(n/2) + O(n)，其中T(1) = O(1)
                            </div>
                            <p class="text-gray-700">
                                根据主定理(Master Theorem)，该递推关系的解为T(n) = O(n log n)
                            </p>
                        </div>
                    </div>
                    
                    <div class="mt-4">
                        <h4 class="font-semibold mb-2">复杂度总结</h4>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white border border-gray-200">
                                <thead>
                                    <tr class="bg-gray-50">
                                        <th class="py-2 px-4 border-b text-left">情况</th>
                                        <th class="py-2 px-4 border-b text-left">时间复杂度</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="py-2 px-4 border-b">最好情况</td>
                                        <td class="py-2 px-4 border-b">O(n log n)</td>
                                    </tr>
                                    <tr class="bg-gray-50">
                                        <td class="py-2 px-4 border-b">平均情况</td>
                                        <td class="py-2 px-4 border-b">O(n log n)</td>
                                    </tr>
                                    <tr>
                                        <td class="py-2 px-4 border-b">最坏情况</td>
                                        <td class="py-2 px-4 border-b">O(n log n)</td>
                                    </tr>
                                    <tr class="bg-gray-50">
                                        <td class="py-2 px-4 border-b">空间复杂度</td>
                                        <td class="py-2 px-4 border-b">O(n)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">归并排序的优化</h3>
                    <p class="text-gray-700 mb-3">
                        基本归并排序可以通过以下方式进行优化，提高实际运行效率：
                    </p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-white p-3 rounded-lg border border-gray-200">
                            <h4 class="font-semibold mb-2">小规模数组使用插入排序</h4>
                            <p class="text-sm text-gray-700">
                                对于小规模数组(n < 15)，插入排序效率高于归并排序，可以减少递归调用开销。
                            </p>
                        </div>
                        <div class="bg-white p-3 rounded-lg border border-gray-200">
                            <h4 class="font-semibold mb-2">判断数组是否已排序</h4>
                            <p class="text-sm text-gray-700">
                                如果arr[mid] <= arr[mid+1]，说明数组已经有序，可以跳过合并步骤。
                            </p>
                        </div>
                        <div class="bg-white p-3 rounded-lg border border-gray-200">
                            <h4 class="font-semibold mb-2">使用原地归并</h4>
                            <p class="text-sm text-gray-700">
                                优化合并步骤，避免使用额外的临时数组，将空间复杂度降低到O(1)。
                            </p>
                        </div>
                        <div class="bg-white p-3 rounded-lg border border-gray-200">
                            <h4 class="font-semibold mb-2">并行化处理</h4>
                            <p class="text-sm text-gray-700">
                                对左右子数组的排序可以并行执行，充分利用多核处理器的优势。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 洛谷相关题目推荐 -->
        <section id="problems" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-merge mb-6 flex items-center">
                <i class="fa fa-tasks mr-2"></i> 洛谷相关题目推荐
            </h2>
            
            <div class="space-y-6">
                <!-- 模板题 -->
                <div>
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <span class="inline-block w-8 h-8 rounded-full bg-green-100 text-green-600 text-center leading-8 mr-2">1</span>
                        模板题
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <a href="https://www.luogu.com.cn/problem/P1177" target="_blank" class="subtopic-item hover:border-merge hover:bg-merge/5 flex flex-col h-full">
                            <div class="font-medium mb-1">P1177 【模板】排序</div>
                            <div class="text-sm text-gray-600 flex-grow">
                                对数组进行排序，直接应用归并排序算法的基础题目
                            </div>
                            <div class="mt-2 text-xs text-gray-500">难度：普及-</div>
                        </a>
                        <a href="https://www.luogu.com.cn/problem/P1908" target="_blank" class="subtopic-item hover:border-merge hover:bg-merge/5 flex flex-col h-full">
                            <div class="font-medium mb-1">P1908 逆序对</div>
                            <div class="text-sm text-gray-600 flex-grow">
                                利用归并排序的思想计算逆序对数量，经典应用
                            </div>
                            <div class="mt-2 text-xs text-gray-500">难度：普及+ / 提高</div>
                        </a>
                    </div>
                </div>
                
                <!-- 入门题 -->
                <div>
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <span class="inline-block w-8 h-8 rounded-full bg-blue-100 text-blue-600 text-center leading-8 mr-2">2</span>
                        入门题
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <a href="https://www.luogu.com.cn/problem/P1271" target="_blank" class="subtopic-item hover:border-merge hover:bg-merge/5 flex flex-col h-full">
                            <div class="font-medium mb-1">P1271 选举学生会</div>
                            <div class="text-sm text-gray-600 flex-grow">
                                对投票结果进行排序统计，可应用归并排序解决
                            </div>
                            <div class="mt-2 text-xs text-gray-500">难度：普及-</div>
                        </a>
                        <a href="https://www.luogu.com.cn/problem/P1093" target="_blank" class="subtopic-item hover:border-merge hover:bg-merge/5 flex flex-col h-full">
                            <div class="font-medium mb-1">P1093 奖学金</div>
                            <div class="text-sm text-gray-600 flex-grow">
                                多关键字排序问题，可扩展归并排序实现多关键字比较
                            </div>
                            <div class="mt-2 text-xs text-gray-500">难度：普及-</div>
                        </a>
                        <a href="https://www.luogu.com.cn/problem/P2676" target="_blank" class="subtopic-item hover:border-merge hover:bg-merge/5 flex flex-col h-full">
                            <div class="font-medium mb-1">P2676 [USACO07DEC] Bookshelf B</div>
                            <div class="text-sm text-gray-600 flex-grow">
                                结合排序和贪心的问题，可使用归并排序预处理
                            </div>
                            <div class="mt-2 text-xs text-gray-500">难度：普及</div>
                        </a>
                    </div>
                </div>
                
                <!-- 进阶题 -->
                <div>
                    <h3 class="text-xl font-semibold mb-4 flex items-center">
                        <span class="inline-block w-8 h-8 rounded-full bg-orange-100 text-orange-600 text-center leading-8 mr-2">3</span>
                        进阶题
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <a href="https://www.luogu.com.cn/problem/P3810" target="_blank" class="subtopic-item hover:border-merge hover:bg-merge/5 flex flex-col h-full">
                            <div class="font-medium mb-1">P3810 【模板】三维偏序（陌上花开）</div>
                            <div class="text-sm text-gray-600 flex-grow">
                                复杂的多维排序问题，可结合归并排序和树状数组解决
                            </div>
                            <div class="mt-2 text-xs text-gray-500">难度：提高+/省选-</div>
                        </a>
                        <a href="https://www.luogu.com.cn/problem/P4402" target="_blank" class="subtopic-item hover:border-merge hover:bg-merge/5 flex flex-col h-full">
                            <div class="font-medium mb-1">P4402 [Cerc2007]robotic sort 机械排序</div>
                            <div class="text-sm text-gray-600 flex-grow">
                                模拟机械排序过程，可利用归并排序思想优化
                            </div>
                            <div class="mt-2 text-xs text-gray-500">难度：提高+/省选-</div>
                        </a>
                        <a href="https://www.luogu.com.cn/problem/P5396" target="_blank" class="subtopic-item hover:border-merge hover:bg-merge/5 flex flex-col h-full">
                            <div class="font-medium mb-1">P5396 【模板】第二类斯特林数·列</div>
                            <div class="text-sm text-gray-600 flex-grow">
                                数论问题，可使用归并排序优化卷积计算
                            </div>
                            <div class="mt-2 text-xs text-gray-500">难度：省选</div>
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        // 初始化代码高亮
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
            
            // 初始化数组演示
            initMergeDemo();
            initCodeExecution();
        });

        // 归并排序动画演示相关功能
        function initMergeDemo() {
            // 合并演示功能
            const mergeDemoBtn = document.getElementById('merge-demo');
            const leftArray = document.getElementById('left-array');
            const rightArray = document.getElementById('right-array');
            const mergedArray = document.getElementById('merged-array');
            
            mergeDemoBtn.addEventListener('click', function() {
                // 重置演示状态
                mergedArray.innerHTML = '';
                
                // 获取左右数组元素
                const leftElements = Array.from(leftArray.getElementsByClassName('array-element'));
                const rightElements = Array.from(rightArray.getElementsByClassName('array-element'));
                
                // 提取数值
                const leftValues = leftElements.map(el => parseInt(el.textContent));
                const rightValues = rightElements.map(el => parseInt(el.textContent));
                
                // 重置高亮
                leftElements.forEach(el => el.classList.remove('array-element-active'));
                rightElements.forEach(el => el.classList.remove('array-element-active'));
                
                // 模拟合并过程
                let i = 0, j = 0;
                const mergeSteps = [];
                
                while (i < leftValues.length && j < rightValues.length) {
                    if (leftValues[i] <= rightValues[j]) {
                        mergeSteps.push({ type: 'left', index: i });
                        i++;
                    } else {
                        mergeSteps.push({ type: 'right', index: j });
                        j++;
                    }
                }
                
                while (i < leftValues.length) {
                    mergeSteps.push({ type: 'left', index: i });
                    i++;
                }
                
                while (j < rightValues.length) {
                    mergeSteps.push({ type: 'right', index: j });
                    j++;
                }
                
                // 执行合并动画
                let stepIndex = 0;
                const animateMerge = () => {
                    if (stepIndex < mergeSteps.length) {
                        const step = mergeSteps[stepIndex];
                        let element, sourceArray;
                        
                        if (step.type === 'left') {
                            sourceArray = leftElements;
                            element = leftElements[step.index];
                        } else {
                            sourceArray = rightElements;
                            element = rightElements[step.index];
                        }
                        
                        // 高亮当前元素
                        sourceArray.forEach(el => el.classList.remove('array-element-active'));
                        element.classList.add('array-element-active');
                        
                        // 复制元素到结果数组
                        setTimeout(() => {
                            const newElement = document.createElement('div');
                            newElement.className = 'array-element array-element-merged';
                            newElement.textContent = element.textContent;
                            mergedArray.appendChild(newElement);
                            
                            stepIndex++;
                            animateMerge();
                        }, 800);
                    } else {
                        // 合并完成，移除高亮
                        leftElements.forEach(el => el.classList.remove('array-element-active'));
                        rightElements.forEach(el => el.classList.remove('array-element-active'));
                    }
                };
                
                animateMerge();
            });
            
            // 归并排序完整演示
            const mergeStartBtn = document.getElementById('merge-start');
            const mergeStepBtn = document.getElementById('merge-step');
            const resetArrayBtn = document.getElementById('reset-array');
            const randomArrayBtn = document.getElementById('random-array');
            const arrayInput = document.getElementById('array-input');
            const mergeVisualization = document.getElementById('merge-visualization');
            const mergeStatus = document.getElementById('merge-status');
            const mergeProgressBar = document.getElementById('merge-progress-bar');
            const mergeStepDescription = document.getElementById('merge-step-description');
            
            let currentArray = [];
            let animationSteps = [];
            let currentStep = 0;
            let isAnimating = false;
            
            // 初始化数组
            function initArray() {
                try {
                    const input = arrayInput.value.trim();
                    currentArray = input.split(',').map(num => parseInt(num)).filter(num => !isNaN(num));
                    if (currentArray.length < 2) throw new Error();
                    renderArray(currentArray);
                    mergeStatus.textContent = "状态: 准备就绪";
                    return true;
                } catch (e) {
                    mergeStatus.textContent = "状态: 请输入有效的数组（至少2个元素）";
                    mergeStatus.classList.add('text-red-500');
                    setTimeout(() => {
                        mergeStatus.classList.remove('text-red-500');
                    }, 2000);
                    return false;
                }
            }
            
            // 生成随机数组
            randomArrayBtn.addEventListener('click', function() {
                const size = Math.floor(Math.random() * 5) + 5; // 5-9个元素
                const arr = [];
                for (let i = 0; i < size; i++) {
                    arr.push(Math.floor(Math.random() * 90) + 10); // 10-99的随机数
                }
                arrayInput.value = arr.join(',');
                initArray();
            });
            
            // 重置数组
            resetArrayBtn.addEventListener('click', function() {
                initArray();
                resetAnimation();
            });
            
            // 重置动画状态
            function resetAnimation() {
                currentStep = 0;
                animationSteps = [];
                isAnimating = false;
                mergeStartBtn.disabled = false;
                mergeStepBtn.disabled = true;
                mergeProgressBar.style.width = '0%';
                mergeStepDescription.textContent = "准备开始归并排序演示...";
            }
            
            // 渲染数组
            function renderArray(arr, left = -1, right = -1, merged = []) {
                mergeVisualization.innerHTML = '';
                const container = document.createElement('div');
                container.className = 'flex flex-wrap justify-center gap-2';
                
                for (let i = 0; i < arr.length; i++) {
                    const element = document.createElement('div');
                    element.className = 'array-element';
                    element.textContent = arr[i];
                    
                    // 标记当前处理范围
                    if (left !== -1 && right !== -1 && i >= left && i <= right) {
                        element.classList.add('bg-merge/20');
                    }
                    
                    // 标记已合并元素
                    if (merged.includes(i)) {
                        element.classList.add('array-element-merged');
                    }
                    
                    container.appendChild(element);
                }
                
                mergeVisualization.appendChild(container);
            }
            
            // 生成归并排序动画步骤
            function generateMergeSteps(arr) {
                const steps = [];
                const tempArr = [...arr];
                
                // 递归生成步骤
                function mergeSortStep(arr, left, right, depth = 0) {
                    steps.push({
                        type: 'split',
                        array: [...arr],
                        left: left,
                        right: right,
                        description: `分解数组: 处理区间 [${left}, ${right}]`
                    });
                    
                    if (left < right) {
                        const mid = Math.floor((left + right) / 2);
                        
                        // 排序左半部分
                        mergeSortStep(arr, left, mid, depth + 1);
                        
                        // 排序右半部分
                        mergeSortStep(arr, mid + 1, right, depth + 1);
                        
                        // 合并
                        const merged = [...arr];
                        let i = left, j = mid + 1, k = left;
                        
                        while (i <= mid && j <= right) {
                            steps.push({
                                type: 'compare',
                                array: [...arr],
                                left: left,
                                right: right,
                                i: i,
                                j: j,
                                description: `比较元素: arr[${i}] = ${arr[i]} 和 arr[${j}] = ${arr[j]}`
                            });
                            
                            if (arr[i] <= arr[j]) {
                                merged[k] = arr[i];
                                i++;
                            } else {
                                merged[k] = arr[j];
                                j++;
                            }
                            k++;
                            
                            steps.push({
                                type: 'merge',
                                array: [...merged],
                                left: left,
                                right: right,
                                mergedUpTo: k - 1,
                                description: `合并元素: 放置 ${merged[k - 1]} 到位置 ${k - 1}`
                            });
                        }
                        
                        while (i <= mid) {
                            merged[k] = arr[i];
                            i++;
                            k++;
                            steps.push({
                                type: 'merge',
                                array: [...merged],
                                left: left,
                                right: right,
                                mergedUpTo: k - 1,
                                description: `合并剩余元素: 放置 ${merged[k - 1]} 到位置 ${k - 1}`
                            });
                        }
                        
                        while (j <= right) {
                            merged[k] = arr[j];
                            j++;
                            k++;
                            steps.push({
                                type: 'merge',
                                array: [...merged],
                                left: left,
                                right: right,
                                mergedUpTo: k - 1,
                                description: `合并剩余元素: 放置 ${merged[k - 1]} 到位置 ${k - 1}`
                            });
                        }
                        
                        // 更新原数组
                        for (let i = left; i <= right; i++) {
                            arr[i] = merged[i];
                        }
                        
                        steps.push({
                            type: 'merged',
                            array: [...arr],
                            left: left,
                            right: right,
                            description: `合并完成: 区间 [${left}, ${right}] 已排序`
                        });
                    } else {
                        steps.push({
                            type: 'base',
                            array: [...arr],
                            left: left,
                            right: right,
                            description: `基本情况: 单个元素 ${arr[left]} 已排序`
                        });
                    }
                }
                
                mergeSortStep(tempArr, 0, tempArr.length - 1);
                return steps;
            }
            
            // 执行一步动画
            function executeStep() {
                if (currentStep < animationSteps.length) {
                    const step = animationSteps[currentStep];
                    mergeStatus.textContent = `状态: ${step.description}`;
                    mergeStepDescription.textContent = step.description;
                    
                    // 渲染当前步骤
                    if (step.type === 'compare') {
                        renderArray(step.array, step.left, step.right);
                        const elements = mergeVisualization.querySelectorAll('.array-element');
                        elements[step.i].classList.add('array-element-active');
                        elements[step.j].classList.add('array-element-active');
                    } else if (step.type === 'merge') {
                        const mergedIndices = [];
                        for (let i = step.left; i <= step.mergedUpTo; i++) {
                            mergedIndices.push(i);
                        }
                        renderArray(step.array, step.left, step.right, mergedIndices);
                    } else {
                        renderArray(step.array, step.left, step.right);
                    }
                    
                    currentStep++;
                    mergeProgressBar.style.width = `${(currentStep / animationSteps.length) * 100}%`;
                    
                    // 检查是否完成
                    if (currentStep >= animationSteps.length) {
                        mergeStatus.textContent = "状态: 归并排序完成";
                        mergeStepDescription.textContent = "归并排序完成，数组已完全有序";
                        mergeStartBtn.disabled = false;
                        mergeStepBtn.disabled = true;
                        isAnimating = false;
                    }
                    
                    return true;
                }
                return false;
            }
            
            // 开始演示
            mergeStartBtn.addEventListener('click', function() {
                if (!initArray()) return;
                
                resetAnimation();
                animationSteps = generateMergeSteps([...currentArray]);
                mergeStartBtn.disabled = true;
                mergeStepBtn.disabled = false;
                isAnimating = true;
                
                // 自动播放动画
                function autoStep() {
                    if (isAnimating && executeStep()) {
                        setTimeout(autoStep, 1000);
                    }
                }
                
                autoStep();
            });
            
            // 单步执行
            mergeStepBtn.addEventListener('click', function() {
                if (animationSteps.length === 0) {
                    if (!initArray()) return;
                    animationSteps = generateMergeSteps([...currentArray]);
                    mergeStartBtn.disabled = true;
                }
                
                executeStep();
            });
            
            // 初始化数组
            initArray();
        }

        // 代码执行高亮功能
        function initCodeExecution() {
            const runCodeBtn = document.getElementById('run-code');
            const codeBlock = document.getElementById('merge-code');
            
            // 代码执行步骤
            const codeSteps = [
                { line: 5, desc: "进入merge函数，准备合并两个有序数组" },
                { line: 6, desc: "计算左子数组长度" },
                { line: 7, desc: "计算右子数组长度" },
                { line: 10, desc: "创建临时数组L和R" },
                { line: 13, desc: "复制数据到左临时数组L" },
                { line: 15, desc: "复制数据到右临时数组R" },
                { line: 18, desc: "初始化合并指针i, j, k" },
                { line: 19, desc: "开始合并两个临时数组" },
                { line: 20, desc: "比较L[i]和R[j]" },
                { line: 21, desc: "L[i] <= R[j]，将L[i]放入结果数组" },
                { line: 22, desc: "移动左数组指针i" },
                { line: 25, desc: "移动结果数组指针k" },
                { line: 19, desc: "继续合并" },
                { line: 20, desc: "比较L[i]和R[j]" },
                { line: 23, desc: "L[i] > R[j]，将R[j]放入结果数组" },
                { line: 24, desc: "移动右数组指针j" },
                { line: 25, desc: "移动结果数组指针k" },
                { line: 19, desc: "继续合并直到一个数组耗尽" },
                { line: 30, desc: "复制左数组剩余元素" },
                { line: 36, desc: "复制右数组剩余元素" },
                { line: 40, desc: "merge函数执行完毕" },
                { line: 45, desc: "进入mergeSort函数" },
                { line: 46, desc: "检查是否需要继续分解" },
                { line: 49, desc: "计算中间位置mid" },
                { line: 52, desc: "递归排序左半部分" },
                { line: 54, desc: "递归排序右半部分" },
                { line: 57, desc: "合并两个有序部分" },
                { line: 69, desc: "调用mergeSort开始排序" },
                { line: 75, desc: "排序完成，输出结果" }
            ];
            
            let currentCodeStep = 0;
            let codeLines = [];
            
            // 初始化代码行
            function initCodeLines() {
                const codeHTML = codeBlock.innerHTML;
                const lines = codeHTML.split('\n');
                codeBlock.innerHTML = lines.map((line, index) => 
                    `<div class="code-line" id="code-line-${index + 1}">${line}</div>`
                ).join('\n');
                
                codeLines = Array.from({ length: lines.length }, (_, i) => 
                    document.getElementById(`code-line-${i + 1}`)
                );
            }
            
            // 重置代码高亮
            function resetCodeHighlight() {
                codeLines.forEach(line => line.classList.remove('code-line-highlight'));
                currentCodeStep = 0;
            }
            
            // 执行代码步骤
            function executeCodeStep() {
                if (currentCodeStep < codeSteps.length) {
                    // 移除上一步高亮
                    if (currentCodeStep > 0) {
                        const prevLine = codeSteps[currentCodeStep - 1].line - 1;
                        if (codeLines[prevLine]) {
                            codeLines[prevLine].classList.remove('code-line-highlight');
                        }
                    }
                    
                    // 添加当前步高亮
                    const step = codeSteps[currentCodeStep];
                    const lineIndex = step.line - 1;
                    if (codeLines[lineIndex]) {
                        codeLines[lineIndex].classList.add('code-line-highlight');
                        // 滚动到当前行
                        codeLines[lineIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                    
                    mergeStatus.textContent = `代码执行: ${step.desc}`;
                    currentCodeStep++;
                    
                    // 如果是最后一步，保持高亮
                    if (currentCodeStep >= codeSteps.length) {
                        mergeStatus.textContent = "代码执行完成: 归并排序成功";
                    } else {
                        // 继续下一步
                        setTimeout(executeCodeStep, 800);
                    }
                }
            }
            
            // 运行代码
            runCodeBtn.addEventListener('click', function() {
                initCodeLines();
                resetCodeHighlight();
                executeCodeStep();
            });
            
            // 初始化代码行
            initCodeLines();
        }
    </script>
</body>
</html>