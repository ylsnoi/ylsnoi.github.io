<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弗洛伊德最短路算法 - 姚老师信奥网</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4A80F0', // 主色调：鲜明的蓝色
                        secondary: '#6C63FF', // 辅助色：紫色
                        syntax: '#FF9800', // 语法部分：橙色
                        algorithm: '#2ECC71', // 算法部分：绿色
                        datastructure: '#9C27B0', // 数据结构部分：深紫色
                        darkbg: '#F8FAFC', // 浅灰白背景
                        cardbg: '#FFFFFF', // 卡片背景
                        hoverbg: '#F0F2F5', // 悬停背景
                        floyd: '#E91E63', // 弗洛伊德算法主题色：粉红色
                        execution: '#FFEB3B', // 执行高亮：黄色
                    },
                    fontFamily: {
                        mono: ['Consolas', 'Monaco', 'Courier New', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .hover-scale {
                @apply transition-transform duration-300 hover:scale-[1.02];
            }
            .category-bg {
                @apply bg-gradient-to-r from-primary/5 to-primary/10;
            }
            .subcategory-bg {
                @apply bg-gradient-to-r from-secondary/5 to-secondary/10;
            }
            .floyd-bg {
                @apply bg-gradient-to-r from-floyd/5 to-floyd/10;
            }
            .card-shadow {
                @apply shadow-sm hover:shadow-md transition-shadow duration-300;
            }
            .nav-item {
                @apply text-gray-700 hover:text-primary transition-colors duration-200;
            }
            .topic-card {
                @apply bg-cardbg rounded-lg p-5 card-shadow hover-scale;
            }
            .subtopic-item {
                @apply bg-white rounded-md p-3 border border-gray-100 hover:border-primary/50 transition-all duration-200 cursor-pointer;
            }
            .topic-header {
                @apply text-xl font-bold text-primary mb-4 flex items-center;
            }
            .subtopic-header {
                @apply font-semibold text-secondary mb-3;
            }
            .floyd-header {
                @apply font-bold text-floyd mb-3;
            }
            .site-title {
                @apply text-2xl font-bold text-primary tracking-tight;
            }
            .code-block {
                @apply bg-gray-800 text-gray-100 rounded-lg p-4 overflow-x-auto my-4 text-sm font-mono;
            }
            .step-item {
                @apply p-3 rounded-md mb-2 border-l-4 border-floyd bg-floyd/5;
            }
            .step-number {
                @apply inline-block w-6 h-6 rounded-full bg-floyd text-white text-center mr-2 text-xs;
            }
            .algorithm-step {
                @apply border-2 border-gray-300 rounded-md p-2 mb-1 bg-gray-50 transition-all duration-500;
            }
            .algorithm-step-active {
                @apply border-floyd bg-floyd/10 transform scale-[1.02];
            }
            .animation-controls {
                @apply flex flex-wrap gap-2 items-center my-4;
            }
            .animation-step {
                @apply bg-gray-100 p-3 rounded-lg mb-4;
            }
            .animation-progress {
                @apply w-full bg-gray-200 rounded-full h-2.5 mb-2;
            }
            .animation-progress-bar {
                @apply bg-floyd h-2.5 rounded-full transition-all duration-300;
            }
            .animation-status {
                @apply text-sm text-gray-600 my-2 p-2 bg-gray-50 rounded;
            }
            .code-line {
                @apply transition-all duration-300;
            }
            .code-line-highlight {
                @apply bg-execution/30 text-gray-900 font-medium;
            }
            .matrix-cell {
                @apply w-12 h-12 flex items-center justify-center border border-gray-300;
            }
            .matrix-cell-highlight {
                @apply bg-execution/30 border-floyd font-bold;
            }
            .matrix-row {
                @apply flex;
            }
        }
    </style>
</head>
<body class="bg-darkbg text-gray-800 font-sans min-h-screen">
    <!-- 顶部导航栏 -->
    <header class="bg-white shadow-sm sticky top-0 z-50">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <i class="fa fa-code text-primary text-3xl"></i>
                <h1 class="site-title">姚老师信奥网</h1>
            </div>
            <div class="hidden md:flex items-center space-x-6">
                <a href="#" class="nav-item">首页</a>
                <a href="#" class="nav-item">课程</a>
                <a href="#" class="nav-item">题库</a>
                <a href="#" class="nav-item">关于我们</a>
            </div>
            <div class="flex items-center space-x-4">
                <!-- 搜索框 -->
                <div class="relative hidden md:block">
                    <input type="text" id="search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-64">
                    <button id="search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                        <i class="fa fa-search"></i>
                    </button>
                </div>
                <div class="md:hidden">
                    <button class="text-gray-700">
                        <i class="fa fa-bars text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
        <!-- 移动端搜索框 -->
        <div class="md:hidden px-4 pb-3">
            <div class="relative">
                <input type="text" id="mobile-search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-full">
                <button id="mobile-search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                    <i class="fa fa-search"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- 面包屑导航 -->
    <div class="bg-white border-b border-gray-200 py-2">
        <div class="container mx-auto px-4">
            <nav class="flex text-sm" aria-label="Breadcrumb">
                <ol class="inline-flex items-center space-x-1 md:space-x-3">
                    <li class="inline-flex items-center">
                        <a href="#" class="text-gray-600 hover:text-primary">
                            <i class="fa fa-home mr-1"></i>首页
                        </a>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary">算法基础</a>
                        </div>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary">图论算法</a>
                        </div>
                    </li>
                    <li aria-current="page">
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <span class="text-floyd font-medium">弗洛伊德最短路算法</span>
                        </div>
                    </li>
                </ol>
            </nav>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 页面标题 -->
        <div class="floyd-bg rounded-lg p-6 mb-8">
            <div class="flex flex-col md:flex-row md:items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-floyd mb-2">弗洛伊德最短路算法</h1>
                    <p class="text-gray-700">
                        弗洛伊德(Floyd)算法是一种用于寻找图中所有顶点间最短路径的动态规划算法。本页面将详细讲解Floyd算法的原理、实现步骤和时间复杂度分析，
                        帮助NOIP竞赛学生掌握这一经典图论算法。
                    </p>
                </div>
                <div class="mt-4 md:mt-0">
                    <div class="flex space-x-3">
                        <a href="#concept" class="bg-floyd hover:bg-floyd/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-book mr-2"></i> 学习概念
                        </a>
                        <a href="#problems" class="bg-white border border-floyd text-floyd hover:bg-floyd/5 px-4 py-2 rounded-md transition-all flex items-center">
                            <i class="fa fa-list-alt mr-2"></i> 查看题目
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- 弗洛伊德算法概述 -->
        <section id="concept" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-floyd mb-6 flex items-center">
                <i class="fa fa-info-circle mr-2"></i> 弗洛伊德算法概述
            </h2>
            <div class="space-y-4">
                <div>
                    <h3 class="text-xl font-semibold mb-3">什么是弗洛伊德算法？</h3>
                    <p class="text-gray-700">
                        弗洛伊德算法是一种用于计算图中所有顶点对之间最短路径的算法，由Robert W. Floyd于1962年提出。它基于动态规划思想，
                        能够处理有向图和无向图，也能处理带有负权边的图，但不能处理包含负权回路的图。
                    </p>
                    <div class="bg-gray-50 p-4 rounded-lg mt-3">
                        <h4 class="font-semibold mb-2">弗洛伊德算法的特点：</h4>
                        <ul class="list-disc pl-5 space-y-2">
                            <li>可以一次性计算出所有顶点对之间的最短路径</li>
                            <li>实现简单，核心代码仅需三重循环</li>
                            <li>时间复杂度为O(n³)，适用于顶点数较少的图（n≤400）</li>
                            <li>使用邻接矩阵存储图的信息</li>
                            <li>能够处理负权边，但不能处理含负权回路的图</li>
                        </ul>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-3">算法基本思想</h3>
                    <p class="text-gray-700 mb-3">
                        弗洛伊德算法的核心思想是"松弛"操作，通过考虑从顶点i到顶点j是否经过顶点k可以缩短路径长度，来更新最短路径。
                        算法的基本步骤如下：
                    </p>
                    
                    <div class="space-y-3">
                        <div class="step-item">
                            <span class="step-number">1</span>
                            <div>
                                <p class="font-medium">初始化距离矩阵</p>
                                <p class="text-sm text-gray-700">创建一个n×n的距离矩阵dist，其中dist[i][j]表示从顶点i到顶点j的初始距离。</p>
                            </div>
                        </div>
                        
                        <div class="step-item">
                            <span class="step-number">2</span>
                            <div>
                                <p class="font-medium">三重循环松弛操作</p>
                                <p class="text-sm text-gray-700">对于每一个中间顶点k（0≤k&lt;n），更新所有顶点对(i,j)的最短路径：
                                如果经过k的路径比当前路径更短，则更新dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])。</p>
                            </div>
                        </div>
                        
                        <div class="step-item">
                            <span class="step-number">3</span>
                            <div>
                                <p class="font-medium">输出结果</p>
                                <p class="text-sm text-gray-700">处理完所有中间顶点后，距离矩阵dist中就存储了所有顶点对之间的最短路径长度。</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-4">
                        <h4 class="font-semibold mb-2">核心递推公式</h4>
                        <div class="bg-gray-800 text-white p-3 rounded-lg text-center">
                            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
                        </div>
                        <p class="text-sm text-gray-700 mt-2">
                            其中，i是起点，j是终点，k是中间顶点。该公式表示：从i到j的最短路径，要么是原来的路径i→j，要么是经过k的路径i→k→j，取两者中的较小值。
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- 弗洛伊德算法动画演示 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-floyd mb-6 flex items-center">
                <i class="fa fa-play-circle mr-2"></i> 弗洛伊德算法执行过程演示
            </h2>
            
            <div class="space-y-6">
                <!-- 算法执行动画 -->
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">Floyd算法执行过程可视化</h3>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-1">
                            <p class="text-gray-700 mb-4">
                                下面的动画展示了Floyd算法计算所有顶点对之间最短路径的完整过程。
                                示例使用一个4顶点的带权图，演示距离矩阵如何逐步更新。
                            </p>
                            
                            <div class="flex space-x-2 mb-4">
                                <button id="floyd-run" class="bg-floyd hover:bg-floyd/90 text-white px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-play mr-2"></i> 运行动画
                                </button>
                                <button id="floyd-step" class="bg-white border border-floyd text-floyd hover:bg-floyd/5 px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-step-forward mr-2"></i> 单步执行
                                </button>
                                <button id="floyd-reset" class="bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded-md transition-all flex items-center">
                                    <i class="fa fa-refresh mr-2"></i> 重置
                                </button>
                            </div>
                            
                            <div id="floyd-status" class="animation-status">
                                状态: 等待开始
                            </div>
                            
                            <div class="mt-4">
                                <h4 class="font-medium text-sm mb-2">当前中间顶点k:</h4>
                                <div id="current-k" class="bg-gray-200 w-10 h-10 rounded-full flex items-center justify-center font-bold text-xl">
                                    -
                                </div>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-white border border-gray-200 rounded-lg p-4 h-80 overflow-y-auto" id="floyd-execution">
                                <div class="text-center text-gray-500 py-10">
                                    <i class="fa fa-arrow-down mb-2"></i>
                                    <p>点击"运行动画"开始演示</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-gray-800 text-gray-100 rounded-lg p-4 h-80 overflow-y-auto font-mono text-sm" id="floyd-code">
                                <div class="code-line" id="floyd-code-1">#include &lt;iostream&gt;</div>
                                <div class="code-line" id="floyd-code-2">#include &lt;climits&gt;</div>
                                <div class="code-line" id="floyd-code-3">using namespace std;</div>
                                <div class="code-line" id="floyd-code-4">&nbsp;</div>
                                <div class="code-line" id="floyd-code-5">const int INF = INT_MAX; // 表示无穷大</div>
                                <div class="code-line" id="floyd-code-6">const int N = 4; // 顶点数量</div>
                                <div class="code-line" id="floyd-code-7">&nbsp;</div>
                                <div class="code-line" id="floyd-code-8">// Floyd算法实现</div>
                                <div class="code-line" id="floyd-code-9">void floyd(int dist[][N]) {</div>
                                <div class="code-line" id="floyd-code-10">&nbsp;&nbsp;// k是中间顶点</div>
                                <div class="code-line" id="floyd-code-11">&nbsp;&nbsp;for (int k = 0; k < N; k++) {</div>
                                <div class="code-line" id="floyd-code-12">&nbsp;&nbsp;&nbsp;&nbsp;// i是起点</div>
                                <div class="code-line" id="floyd-code-13">&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i < N; i++) {</div>
                                <div class="code-line" id="floyd-code-14">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// j是终点</div>
                                <div class="code-line" id="floyd-code-15">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j < N; j++) {</div>
                                <div class="code-line" id="floyd-code-16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 松弛操作</div>
                                <div class="code-line" id="floyd-code-17">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (dist[i][k] != INF && dist[k][j] != INF &&</div>
                                <div class="code-line" id="floyd-code-18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist[i][j] > dist[i][k] + dist[k][j]) {</div>
                                <div class="code-line" id="floyd-code-19">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dist[i][j] = dist[i][k] + dist[k][j];</div>
                                <div class="code-line" id="floyd-code-20">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="floyd-code-21">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="floyd-code-22">&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="floyd-code-23">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="floyd-code-24">}</div>
                                <div class="code-line" id="floyd-code-25">&nbsp;</div>
                                <div class="code-line" id="floyd-code-26">int main() {</div>
                                <div class="code-line" id="floyd-code-27">&nbsp;&nbsp;// 初始化距离矩阵</div>
                                <div class="code-line" id="floyd-code-28">&nbsp;&nbsp;int dist[N][N] = {</div>
                                <div class="code-line" id="floyd-code-29">&nbsp;&nbsp;&nbsp;&nbsp;{0, 5, INF, 10},</div>
                                <div class="code-line" id="floyd-code-30">&nbsp;&nbsp;&nbsp;&nbsp;{INF, 0, 3, INF},</div>
                                <div class="code-line" id="floyd-code-31">&nbsp;&nbsp;&nbsp;&nbsp;{INF, INF, 0, 1},</div>
                                <div class="code-line" id="floyd-code-32">&nbsp;&nbsp;&nbsp;&nbsp;{INF, INF, INF, 0}</div>
                                <div class="code-line" id="floyd-code-33">&nbsp;&nbsp;};</div>
                                <div class="code-line" id="floyd-code-34">&nbsp;</div>
                                <div class="code-line" id="floyd-code-35">&nbsp;&nbsp;floyd(dist);</div>
                                <div class="code-line" id="floyd-code-36">&nbsp;</div>
                                <div class="code-line" id="floyd-code-37">&nbsp;&nbsp;// 输出结果</div>
                                <div class="code-line" id="floyd-code-38">&nbsp;&nbsp;cout << "所有顶点对之间的最短路径：" << endl;</div>
                                <div class="code-line" id="floyd-code-39">&nbsp;&nbsp;for (int i = 0; i < N; i++) {</div>
                                <div class="code-line" id="floyd-code-40">&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j < N; j++) {</div>
                                <div class="code-line" id="floyd-code-41">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (dist[i][j] == INF) {</div>
                                <div class="code-line" id="floyd-code-42">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout << "INF\t";</div>
                                <div class="code-line" id="floyd-code-43">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</div>
                                <div class="code-line" id="floyd-code-44">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout << dist[i][j] << "\t";</div>
                                <div class="code-line" id="floyd-code-45">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="floyd-code-46">&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="floyd-code-47">&nbsp;&nbsp;&nbsp;&nbsp;cout << endl;</div>
                                <div class="code-line" id="floyd-code-48">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="floyd-code-49">&nbsp;</div>
                                <div class="code-line" id="floyd-code-50">&nbsp;&nbsp;return 0;</div>
                                <div class="code-line" id="floyd-code-51">}</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 距离矩阵可视化 -->
                    <div class="mt-6">
                        <h4 class="font-semibold mb-3">距离矩阵动态变化</h4>
                        <div class="overflow-x-auto">
                            <div id="distance-matrix" class="border border-gray-300 inline-block">
                                <!-- 矩阵的第一行：顶点标签 -->
                                <div class="matrix-row bg-gray-100 font-bold">
                                    <div class="matrix-cell w-16">i\j</div>
                                    <div class="matrix-cell">0</div>
                                    <div class="matrix-cell">1</div>
                                    <div class="matrix-cell">2</div>
                                    <div class="matrix-cell">3</div>
                                </div>
                                <!-- 矩阵内容行 -->
                                <div class="matrix-row">
                                    <div class="matrix-cell bg-gray-100 font-bold">0</div>
                                    <div class="matrix-cell" id="dist-0-0">0</div>
                                    <div class="matrix-cell" id="dist-0-1">5</div>
                                    <div class="matrix-cell" id="dist-0-2">INF</div>
                                    <div class="matrix-cell" id="dist-0-3">10</div>
                                </div>
                                <div class="matrix-row">
                                    <div class="matrix-cell bg-gray-100 font-bold">1</div>
                                    <div class="matrix-cell" id="dist-1-0">INF</div>
                                    <div class="matrix-cell" id="dist-1-1">0</div>
                                    <div class="matrix-cell" id="dist-1-2">3</div>
                                    <div class="matrix-cell" id="dist-1-3">INF</div>
                                </div>
                                <div class="matrix-row">
                                    <div class="matrix-cell bg-gray-100 font-bold">2</div>
                                    <div class="matrix-cell" id="dist-2-0">INF</div>
                                    <div class="matrix-cell" id="dist-2-1">INF</div>
                                    <div class="matrix-cell" id="dist-2-2">0</div>
                                    <div class="matrix-cell" id="dist-2-3">1</div>
                                </div>
                                <div class="matrix-row">
                                    <div class="matrix-cell bg-gray-100 font-bold">3</div>
                                    <div class="matrix-cell" id="dist-3-0">INF</div>
                                    <div class="matrix-cell" id="dist-3-1">INF</div>
                                    <div class="matrix-cell" id="dist-3-2">INF</div>
                                    <div class="matrix-cell" id="dist-3-3">0</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 弗洛伊德算法实现详解 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-floyd mb-6 flex items-center">
                <i class="fa fa-code-fork mr-2"></i> 弗洛伊德算法实现详解
            </h2>
            
            <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold mb-3">算法实现步骤</h3>
                    
                    <div class="space-y-4">
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <h4 class="font-semibold text-floyd mb-2">1. 数据结构选择</h4>
                            <p class="text-gray-700 mb-2">
                                弗洛伊德算法通常使用邻接矩阵来表示图，对于一个有n个顶点的图，使用n×n的二维数组dist存储距离信息：
                            </p>
                            <ul class="list-disc pl-5 text-gray-700 mb-2">
                                <li>dist[i][j]表示从顶点i到顶点j的最短距离</li>
                                <li>dist[i][i] = 0（顶点到自身的距离为0）</li>
                                <li>如果顶点i和j之间没有直接边相连，则dist[i][j] = INF（一个很大的值）</li>
                            </ul>
                            <pre class="code-block text-xs"><code class="language-cpp">const int INF = 1e9; // 表示无穷大，根据题目数据范围调整
const int MAXN = 100; // 最大顶点数
int dist[MAXN][MAXN]; // 距离矩阵</code></pre>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <h4 class="font-semibold text-floyd mb-2">2. 初始化距离矩阵</h4>
                            <p class="text-gray-700 mb-2">
                                根据图的实际情况初始化距离矩阵：
                            </p>
                            <pre class="code-block text-xs"><code class="language-cpp">// 初始化距离矩阵
void init(int n) {
    // 1. 初始化为无穷大
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) {
                dist[i][j] = 0; // 顶点到自身距离为0
            } else {
                dist[i][j] = INF; // 其他初始化为无穷大
            }
        }
    }
    
    // 2. 读入边的信息，更新距离矩阵
    // 假设有m条边
    int m, u, v, w;
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> u >> v >> w; // 读入一条从u到v的边，权重为w
        dist[u][v] = w;
        
        // 如果是无向图，还需要添加下面一行
        // dist[v][u] = w;
    }
}</code></pre>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <h4 class="font-semibold text-floyd mb-2">3. 核心算法实现</h4>
                            <p class="text-gray-700 mb-2">
                                使用三重循环实现Floyd算法的核心松弛操作：
                            </p>
                            <pre class="code-block text-xs"><code class="language-cpp">// Floyd算法核心实现
void floyd(int n) {
    // k为中间顶点
    for (int k = 0; k < n; k++) {
        // i为起点
        for (int i = 0; i < n; i++) {
            // j为终点
            for (int j = 0; j < n; j++) {
                // 松弛操作：如果经过k的路径更短，则更新
                if (dist[i][k] != INF && dist[k][j] != INF && 
                    dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
}</code></pre>
                            <p class="text-gray-700 text-sm mt-2">
                                注意：必须先判断dist[i][k]和dist[k][j]是否为INF，否则可能会因为整数溢出导致错误结果。
                            </p>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <h4 class="font-semibold text-floyd mb-2">4. 输出最短路径</h4>
                            <p class="text-gray-700 mb-2">
                                算法执行完成后，距离矩阵中就存储了所有顶点对之间的最短路径：
                            </p>
                            <pre class="code-block text-xs"><code class="language-cpp">// 输出所有顶点对之间的最短路径
void printResult(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (dist[i][j] == INF) {
                cout << "INF "; // 表示不可达
            } else {
                cout << dist[i][j] << " ";
            }
        }
        cout << endl;
    }
}</code></pre>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-3">完整代码示例</h3>
                    <p class="text-gray-700 mb-3">
                        下面是一个完整的Floyd算法实现，用于计算有向图中所有顶点对之间的最短路径：
                    </p>
                    <pre class="code-block"><code class="language-cpp">#include <iostream>
#include <cstring>
using namespace std;

const int INF = 1e9; // 表示无穷大
const int MAXN = 100; // 最大顶点数
int dist[MAXN][MAXN]; // 距离矩阵

// 初始化距离矩阵
void init(int n) {
    // 初始化为无穷大
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = (i == j) ? 0 : INF;
        }
    }
}

// Floyd算法核心实现
void floyd(int n) {
    // k为中间顶点
    for (int k = 0; k < n; k++) {
        // i为起点
        for (int i = 0; i < n; i++) {
            // j为终点
            for (int j = 0; j < n; j++) {
                // 松弛操作：如果经过k的路径更短，则更新
                if (dist[i][k] != INF && dist[k][j] != INF && 
                    dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
}

// 输出所有顶点对之间的最短路径
void printResult(int n) {
    cout << "所有顶点对之间的最短路径：" << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (dist[i][j] == INF) {
                cout << "INF\t";
            } else {
                cout << dist[i][j] << "\t";
            }
        }
        cout << endl;
    }
}

int main() {
    int n, m;
    cout << "请输入顶点数和边数：";
    cin >> n >> m;
    
    init(n);
    
    cout << "请输入" << m << "条边的信息（u v w）：" << endl;
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        dist[u][v] = w;
    }
    
    floyd(n);
    printResult(n);
    
    return 0;
}</code></pre>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-3">路径记录与输出</h3>
                    <p class="text-gray-700 mb-3">
                        上述代码只能计算最短路径长度，如果需要记录并输出具体的路径，可以增加一个路径矩阵：
                    </p>
                    <pre class="code-block"><code class="language-cpp">#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

const int INF = 1e9;
const int MAXN = 100;
int dist[MAXN][MAXN]; // 距离矩阵
int path[MAXN][MAXN]; // 路径矩阵，path[i][j]表示i到j的最短路径中j的前一个顶点

// 初始化
void init(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = (i == j) ? 0 : INF;
            path[i][j] = -1; // 初始化为-1，表示没有前一个顶点
        }
    }
}

// 带路径记录的Floyd算法
void floyd(int n) {
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF && 
                    dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = k; // 记录路径：i到j的路径经过k
                }
            }
        }
    }
}

// 递归输出路径
void printPath(int i, int j) {
    if (path[i][j] == -1) {
        return;
    }
    printPath(i, path[i][j]);
    cout << path[i][j] << " -> ";
}

// 输出从i到j的完整路径和距离
void showPath(int i, int j) {
    if (dist[i][j] == INF) {
        cout << i << " 到 " << j << " 没有路径" << endl;
        return;
    }
    cout << i << " -> ";
    printPath(i, j);
    cout << j << "，距离为：" << dist[i][j] << endl;
}

int main() {
    // 主函数实现与前面类似，略
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- 算法分析与优化 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-floyd mb-6 flex items-center">
                <i class="fa fa-line-chart mr-2"></i> 算法分析与优化
            </h2>
            
            <div class="space-y-6">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h3 class="font-semibold text-lg mb-3">时间复杂度分析</h3>
                        <p class="text-gray-700 mb-3">
                            弗洛伊德算法的时间复杂度主要由三重循环决定：
                        </p>
                        <div class="bg-gray-800 text-white p-3 rounded-lg text-center mb-3">
                            时间复杂度：O(n³)
                        </div>
                        <p class="text-gray-700">
                            其中n是图中顶点的数量。这是因为算法有三层嵌套循环，每层循环都需要遍历所有顶点。
                        </p>
                        <p class="text-gray-700 mt-2">
                            空间复杂度为O(n²)，主要用于存储距离矩阵。
                        </p>
                    </div>
                    
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h3 class="font-semibold text-lg mb-3">适用场景</h3>
                        <p class="text-gray-700 mb-3">
                            弗洛伊德算法适用于以下场景：
                        </p>
                        <ul class="list-disc pl-5 space-y-2 text-gray-700">
                            <li>需要计算图中所有顶点对之间的最短路径</li>
                            <li>图中顶点数量较少（通常n≤400）</li>
                            <li>图中可能包含负权边，但没有负权回路</li>
                            <li>实现简单，对代码长度有要求的场景</li>
                        </ul>
                        <p class="text-gray-700 mt-3">
                            对于顶点数量较多的图，建议使用Dijkstra算法（单源最短路径，多次调用）或SPFA算法。
                        </p>
                    </div>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">常见优化与注意事项</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <h4 class="font-semibold text-floyd mb-2">1. 无穷大值的选择</h4>
                            <p class="text-gray-700 text-sm">
                                INF的值应根据题目数据范围合理选择，既要有足够大，又要避免两个INF相加导致整数溢出。
                                例如：如果最大边权为1e5，顶点数为1e3，则INF应大于1e8（1e5×1e3）。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold text-floyd mb-2">2. 负权回路检测</h4>
                            <p class="text-gray-700 text-sm">
                                可以通过检查dist[i][i]是否小于0来检测图中是否存在负权回路，如果存在dist[i][i] < 0，
                                则说明从顶点i出发经过某个回路回到i的总权值为负。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold text-floyd mb-2">3. 无向图处理</h4>
                            <p class="text-gray-700 text-sm">
                                对于无向图，每条边需要在矩阵中对称存储，即dist[u][v] = dist[v][u] = w。
                            </p>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold text-floyd mb-2">4. 稀疏图优化</h4>
                            <p class="text-gray-700 text-sm">
                                对于稀疏图，可以先将邻接矩阵转换为邻接表，再结合其他算法优化，但会增加代码复杂度。
                            </p>
                        </div>
                    </div>
                </div>
                
                <div class="bg-gray-50 p-4 rounded-lg">
                    <h3 class="font-semibold text-lg mb-3">与其他最短路径算法的比较</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full border border-gray-200">
                            <thead>
                                <tr class="bg-gray-100">
                                    <th class="py-2 px-4 border-b text-left">算法</th>
                                    <th class="py-2 px-4 border-b text-left">适用场景</th>
                                    <th class="py-2 px-4 border-b text-left">时间复杂度</th>
                                    <th class="py-2 px-4 border-b text-left">能否处理负权边</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="py-2 px-4 border-b font-medium">Floyd</td>
                                    <td class="py-2 px-4 border-b">所有顶点对最短路径</td>
                                    <td class="py-2 px-4 border-b">O(n³)</td>
                                    <td class="py-2 px-4 border-b">能（无负权回路）</td>
                                </tr>
                                <tr>
                                    <td class="py-2 px-4 border-b font-medium">Dijkstra</td>
                                    <td class="py-2 px-4 border-b">单源最短路径</td>
                                    <td class="py-2 px-4 border-b">O(m log n)</td>
                                    <td class="py-2 px-4 border-b">不能</td>
                                </tr>
                                <tr>
                                    <td class="py-2 px-4 border-b font-medium">Bellman-Ford</td>
                                    <td class="py-2 px-4 border-b">单源最短路径</td>
                                    <td class="py-2 px-4 border-b">O(nm)</td>
                                    <td class="py-2 px-4 border-b">能（可检测负权回路）</td>
                                </tr>
                                <tr>
                                    <td class="py-2 px-4 border-b font-medium">SPFA</td>
                                    <td class="py-2 px-4 border-b">单源最短路径</td>
                                    <td class="py-2 px-4 border-b">平均O(m)，最坏O(nm)</td>
                                    <td class="py-2 px-4 border-b">能（可检测负权回路）</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- 推荐练习题 -->
        <section id="problems" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-floyd mb-6 flex items-center">
                <i class="fa fa-tasks mr-2"></i> 推荐练习题（洛谷）
            </h2>
            
            <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">1. 模板题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-gray-50 p-4 rounded-lg hover-scale">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h4 class="font-semibold text-lg mb-1">P1144 最短路计数</h4>
                                    <p class="text-gray-700 text-sm">
                                        给定一个无向图，求从1号顶点到其他所有顶点的最短路径的条数。
                                    </p>
                                </div>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">入门</span>
                            </div>
                            <div class="mt-3 flex justify-between items-center">
                                <div class="text-sm text-gray-500">
                                    <i class="fa fa-clock-o mr-1"></i> 时间限制：1.00s
                                </div>
                                <a href="https://www.luogu.com.cn/problem/P1144" target="_blank" class="text-primary hover:text-primary/80 text-sm flex items-center">
                                    查看题目 <i class="fa fa-external-link ml-1"></i>
                                </a>
                            </div>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg hover-scale">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h4 class="font-semibold text-lg mb-1">P2910 [USACO08OPEN] Clear And Present Danger S</h4>
                                    <p class="text-gray-700 text-sm">
                                        计算一条给定路线上所有连续城市之间的最短路径之和，适合练习Floyd算法。
                                    </p>
                                </div>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">入门</span>
                            </div>
                            <div class="mt-3 flex justify-between items-center">
                                <div class="text-sm text-gray-500">
                                    <i class="fa fa-clock-o mr-1"></i> 时间限制：1.00s
                                </div>
                                <a href="https://www.luogu.com.cn/problem/P2910" target="_blank" class="text-primary hover:text-primary/80 text-sm flex items-center">
                                    查看题目 <i class="fa fa-external-link ml-1"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">2. 入门题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-gray-50 p-4 rounded-lg hover-scale">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h4 class="font-semibold text-lg mb-1">P1346 电车</h4>
                                    <p class="text-gray-700 text-sm">
                                        给定一个有向图，部分边可以免费通行，求从起点到终点的最小费用。
                                    </p>
                                </div>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <div class="mt-3 flex justify-between items-center">
                                <div class="text-sm text-gray-500">
                                    <i class="fa fa-clock-o mr-1"></i> 时间限制：1.00s
                                </div>
                                <a href="https://www.luogu.com.cn/problem/P1346" target="_blank" class="text-primary hover:text-primary/80 text-sm flex items-center">
                                    查看题目 <i class="fa fa-external-link ml-1"></i>
                                </a>
                            </div>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg hover-scale">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h4 class="font-semibold text-lg mb-1">P2888 [USACO07NOV] Cow Hurdles S</h4>
                                    <p class="text-gray-700 text-sm">
                                        求从起点到终点路径上的最大边权的最小值，可使用Floyd思想变形解决。
                                    </p>
                                </div>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <div class="mt-3 flex justify-between items-center">
                                <div class="text-sm text-gray-500">
                                    <i class="fa fa-clock-o mr-1"></i> 时间限制：1.00s
                                </div>
                                <a href="https://www.luogu.com.cn/problem/P2888" target="_blank" class="text-primary hover:text-primary/80 text-sm flex items-center">
                                    查看题目 <i class="fa fa-external-link ml-1"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary">3. 进阶题</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-gray-50 p-4 rounded-lg hover-scale">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h4 class="font-semibold text-lg mb-1">P1119 灾后重建</h4>
                                    <p class="text-gray-700 text-sm">
                                        结合时间维度的最短路径问题，城镇会按时间顺序修复，需要动态回答最短路径查询。
                                    </p>
                                </div>
                                <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">普及+</span>
                            </div>
                            <div class="mt-3 flex justify-between items-center">
                                <div class="text-sm text-gray-500">
                                    <i class="fa fa-clock-o mr-1"></i> 时间限制：1.00s
                                </div>
                                <a href="https://www.luogu.com.cn/problem/P1119" target="_blank" class="text-primary hover:text-primary/80 text-sm flex items-center">
                                    查看题目 <i class="fa fa-external-link ml-1"></i>
                                </a>
                            </div>
                        </div>
                        
                        <div class="bg-gray-50 p-4 rounded-lg hover-scale">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h4 class="font-semibold text-lg mb-1">P3385 【模板】负环判断</h4>
                                    <p class="text-gray-700 text-sm">
                                        判断图中是否存在负权回路，可使用Floyd算法或Bellman-Ford算法实现。
                                    </p>
                                </div>
                                <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">普及+</span>
                            </div>
                            <div class="mt-3 flex justify-between items-center">
                                <div class="text-sm text-gray-500">
                                    <i class="fa fa-clock-o mr-1"></i> 时间限制：1.00s
                                </div>
                                <a href="https://www.luogu.com.cn/problem/P3385" target="_blank" class="text-primary hover:text-primary/80 text-sm flex items-center">
                                    查看题目 <i class="fa fa-external-link ml-1"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        // 初始化代码高亮
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
            
            // 初始化Floyd算法演示数据
            const initialDist = [
                [0, 5, "INF", 10],
                ["INF", 0, 3, "INF"],
                ["INF", "INF", 0, 1],
                ["INF", "INF", "INF", 0]
            ];
            
            // 算法执行步骤
            const steps = [
                {k: 0, i: 0, j: 0, action: "开始处理k=0", codeLines: [11]},
                {k: 0, i: 0, j: 1, action: "检查i=0,j=1: 不更新", codeLines: [13,15]},
                {k: 0, i: 0, j: 2, action: "检查i=0,j=2: 不更新", codeLines: [13,15]},
                {k: 0, i: 0, j: 3, action: "检查i=0,j=3: 不更新", codeLines: [13,15]},
                {k: 0, i: 1, j: 0, action: "检查i=1,j=0: 不更新", codeLines: [13,15]},
                {k: 0, i: 1, j: 1, action: "检查i=1,j=1: 不更新", codeLines: [13,15]},
                {k: 0, i: 1, j: 2, action: "检查i=1,j=2: 不更新", codeLines: [13,15]},
                {k: 0, i: 1, j: 3, action: "检查i=1,j=3: 不更新", codeLines: [13,15]},
                {k: 0, i: 2, j: 0, action: "检查i=2,j=0: 不更新", codeLines: [13,15]},
                {k: 0, i: 2, j: 1, action: "检查i=2,j=1: 不更新", codeLines: [13,15]},
                {k: 0, i: 2, j: 2, action: "检查i=2,j=2: 不更新", codeLines: [13,15]},
                {k: 0, i: 2, j: 3, action: "检查i=2,j=3: 不更新", codeLines: [13,15]},
                {k: 0, i: 3, j: 0, action: "检查i=3,j=0: 不更新", codeLines: [13,15]},
                {k: 0, i: 3, j: 1, action: "检查i=3,j=1: 不更新", codeLines: [13,15]},
                {k: 0, i: 3, j: 2, action: "检查i=3,j=2: 不更新", codeLines: [13,15]},
                {k: 0, i: 3, j: 3, action: "检查i=3,j=3: 不更新", codeLines: [13,15]},
                {k: 1, i: 0, j: 0, action: "开始处理k=1", codeLines: [11]},
                {k: 1, i: 0, j: 1, action: "检查i=0,j=1: 不更新", codeLines: [13,15]},
                {k: 1, i: 0, j: 2, action: "更新i=0,j=2: 5+3=8（原INF）", codeLines: [13,15,19], dist: {0: {2: 8}}},
                {k: 1, i: 0, j: 3, action: "检查i=0,j=3: 不更新", codeLines: [13,15]},
                {k: 1, i: 1, j: 0, action: "检查i=1,j=0: 不更新", codeLines: [13,15]},
                {k: 1, i: 1, j: 1, action: "检查i=1,j=1: 不更新", codeLines: [13,15]},
                {k: 1, i: 1, j: 2, action: "检查i=1,j=2: 不更新", codeLines: [13,15]},
                {k: 1, i: 1, j: 3, action: "检查i=1,j=3: 不更新", codeLines: [13,15]},
                {k: 1, i: 2, j: 0, action: "检查i=2,j=0: 不更新", codeLines: [13,15]},
                {k: 1, i: 2, j: 1, action: "检查i=2,j=1: 不更新", codeLines: [13,15]},
                {k: 1, i: 2, j: 2, action: "检查i=2,j=2: 不更新", codeLines: [13,15]},
                {k: 1, i: 2, j: 3, action: "检查i=2,j=3: 不更新", codeLines: [13,15]},
                {k: 1, i: 3, j: 0, action: "检查i=3,j=0: 不更新", codeLines: [13,15]},
                {k: 1, i: 3, j: 1, action: "检查i=3,j=1: 不更新", codeLines: [13,15]},
                {k: 1, i: 3, j: 2, action: "检查i=3,j=2: 不更新", codeLines: [13,15]},
                {k: 1, i: 3, j: 3, action: "检查i=3,j=3: 不更新", codeLines: [13,15]},
                {k: 2, i: 0, j: 0, action: "开始处理k=2", codeLines: [11]},
                {k: 2, i: 0, j: 1, action: "检查i=0,j=1: 不更新", codeLines: [13,15]},
                {k: 2, i: 0, j: 2, action: "检查i=0,j=2: 不更新", codeLines: [13,15]},
                {k: 2, i: 0, j: 3, action: "更新i=0,j=3: 8+1=9（原10）", codeLines: [13,15,19], dist: {0: {3: 9}}},
                {k: 2, i: 1, j: 0, action: "检查i=1,j=0: 不更新", codeLines: [13,15]},
                {k: 2, i: 1, j: 1, action: "检查i=1,j=1: 不更新", codeLines: [13,15]},
                {k: 2, i: 1, j: 2, action: "检查i=1,j=2: 不更新", codeLines: [13,15]},
                {k: 2, i: 1, j: 3, action: "更新i=1,j=3: 3+1=4（原INF）", codeLines: [13,15,19], dist: {1: {3: 4}}},
                {k: 2, i: 2, j: 0, action: "检查i=2,j=0: 不更新", codeLines: [13,15]},
                {k: 2, i: 2, j: 1, action: "检查i=2,j=1: 不更新", codeLines: [13,15]},
                {k: 2, i: 2, j: 2, action: "检查i=2,j=2: 不更新", codeLines: [13,15]},
                {k: 2, i: 2, j: 3, action: "检查i=2,j=3: 不更新", codeLines: [13,15]},
                {k: 2, i: 3, j: 0, action: "检查i=3,j=0: 不更新", codeLines: [13,15]},
                {k: 2, i: 3, j: 1, action: "检查i=3,j=1: 不更新", codeLines: [13,15]},
                {k: 2, i: 3, j: 2, action: "检查i=3,j=2: 不更新", codeLines: [13,15]},
                {k: 2, i: 3, j: 3, action: "检查i=3,j=3: 不更新", codeLines: [13,15]},
                {k: 3, i: 0, j: 0, action: "开始处理k=3", codeLines: [11]},
                {k: 3, i: 0, j: 1, action: "检查i=0,j=1: 不更新", codeLines: [13,15]},
                {k: 3, i: 0, j: 2, action: "检查i=0,j=2: 不更新", codeLines: [13,15]},
                {k: 3, i: 0, j: 3, action: "检查i=0,j=3: 不更新", codeLines: [13,15]},
                {k: 3, i: 1, j: 0, action: "检查i=1,j=0: 不更新", codeLines: [13,15]},
                {k: 3, i: 1, j: 1, action: "检查i=1,j=1: 不更新", codeLines: [13,15]},
                {k: 3, i: 1, j: 2, action: "检查i=1,j=2: 不更新", codeLines: [13,15]},
                {k: 3, i: 1, j: 3, action: "检查i=1,j=3: 不更新", codeLines: [13,15]},
                {k: 3, i: 2, j: 0, action: "检查i=2,j=0: 不更新", codeLines: [13,15]},
                {k: 3, i: 2, j: 1, action: "检查i=2,j=1: 不更新", codeLines: [13,15]},
                {k: 3, i: 2, j: 2, action: "检查i=2,j=2: 不更新", codeLines: [13,15]},
                {k: 3, i: 2, j: 3, action: "检查i=2,j=3: 不更新", codeLines: [13,15]},
                {k: 3, i: 3, j: 0, action: "检查i=3,j=0: 不更新", codeLines: [13,15]},
                {k: 3, i: 3, j: 1, action: "检查i=3,j=1: 不更新", codeLines: [13,15]},
                {k: 3, i: 3, j: 2, action: "检查i=3,j=2: 不更新", codeLines: [13,15]},
                {k: 3, i: 3, j: 3, action: "检查i=3,j=3: 不更新", codeLines: [13,15]},
                {k: -1, i: -1, j: -1, action: "算法执行完成！所有顶点对之间的最短路径已计算完毕", codeLines: []}
            ];
            
            let currentStep = 0;
            let isRunning = false;
            let animationInterval;
            let currentDist = JSON.parse(JSON.stringify(initialDist));
            
            // 重置演示
            function resetDemo() {
                currentStep = 0;
                isRunning = false;
                clearInterval(animationInterval);
                currentDist = JSON.parse(JSON.stringify(initialDist));
                
                // 重置矩阵显示
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        document.getElementById(`dist-${i}-${j}`).textContent = currentDist[i][j];
                        document.getElementById(`dist-${i}-${j}`).classList.remove('matrix-cell-highlight');
                    }
                }
                
                // 重置代码高亮
                for (let i = 1; i <= 51; i++) {
                    const line = document.getElementById(`floyd-code-${i}`);
                    if (line) line.classList.remove('code-line-highlight');
                }
                
                // 重置状态
                document.getElementById('floyd-status').textContent = '状态: 等待开始';
                document.getElementById('current-k').textContent = '-';
                document.getElementById('floyd-execution').innerHTML = `
                    <div class="text-center text-gray-500 py-10">
                        <i class="fa fa-arrow-down mb-2"></i>
                        <p>点击"运行动画"开始演示</p>
                    </div>
                `;
            }
            
            // 执行下一步
            function executeStep() {
                if (currentStep >= steps.length) {
                    isRunning = false;
                    clearInterval(animationInterval);
                    return;
                }
                
                // 清除上一步的高亮
                for (let i = 1; i <= 51; i++) {
                    const line = document.getElementById(`floyd-code-${i}`);
                    if (line) line.classList.remove('code-line-highlight');
                }
                
                // 清除上一步的矩阵高亮
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        document.getElementById(`dist-${i}-${j}`).classList.remove('matrix-cell-highlight');
                    }
                }
                
                const step = steps[currentStep];
                
                // 更新状态
                document.getElementById('floyd-status').textContent = `状态: ${step.action}`;
                
                // 更新当前k值
                document.getElementById('current-k').textContent = step.k !== -1 ? step.k : '-';
                
                // 高亮当前代码行
                step.codeLines.forEach(lineNum => {
                    const line = document.getElementById(`floyd-code-${lineNum}`);
                    if (line) line.classList.add('code-line-highlight');
                });
                
                // 更新执行日志
                const executionLog = document.getElementById('floyd-execution');
                const logEntry = document.createElement('div');
                logEntry.className = 'mb-2 p-2 bg-gray-50 rounded';
                if (step.k !== -1) {
                    logEntry.innerHTML = `<strong>k=${step.k}, i=${step.i}, j=${step.j}:</strong> ${step.action}`;
                } else {
                    logEntry.innerHTML = `<strong>${step.action}</strong>`;
                }
                executionLog.appendChild(logEntry);
                executionLog.scrollTop = executionLog.scrollHeight;
                
                // 更新距离矩阵
                if (step.dist) {
                    for (const i in step.dist) {
                        for (const j in step.dist[i]) {
                            currentDist[i][j] = step.dist[i][j];
                            document.getElementById(`dist-${i}-${j}`).textContent = step.dist[i][j];
                            document.getElementById(`dist-${i}-${j}`).classList.add('matrix-cell-highlight');
                        }
                    }
                } else if (step.i !== -1 && step.j !== -1) {
                    // 高亮当前正在检查的单元格
                    document.getElementById(`dist-${step.i}-${step.j}`).classList.add('matrix-cell-highlight');
                }
                
                currentStep++;
            }
            
            // 自动播放动画
            function startAnimation() {
                if (isRunning) return;
                
                isRunning = true;
                document.getElementById('floyd-status').textContent = '状态: 动画运行中...';
                
                animationInterval = setInterval(() => {
                    if (currentStep >= steps.length) {
                        clearInterval(animationInterval);
                        isRunning = false;
                        document.getElementById('floyd-status').textContent = '状态: 动画已完成';
                        return;
                    }
                    executeStep();
                }, 1000);
            }
            
            // 绑定按钮事件
            document.getElementById('floyd-run').addEventListener('click', startAnimation);
            document.getElementById('floyd-step').addEventListener('click', () => {
                if (isRunning) return;
                executeStep();
            });
            document.getElementById('floyd-reset').addEventListener('click', resetDemo);
            
            // 初始化演示
            resetDemo();
        });
    </script>
</body>
</html>