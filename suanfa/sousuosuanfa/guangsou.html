<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>广度优先搜索(BFS) - 姚老师信奥网</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4A80F0', // 主色调：鲜明的蓝色
                        secondary: '#6C63FF', // 辅助色：紫色
                        syntax: '#FF9800', // 语法部分：橙色
                        algorithm: '#2ECC71', // 算法部分：绿色
                        datastructure: '#9C27B0', // 数据结构部分：深紫色
                        darkbg: '#F8FAFC', // 浅灰白背景
                        cardbg: '#FFFFFF', // 卡片背景
                        hoverbg: '#F0F2F5', // 悬停背景
                        bfs: '#03A9F4', // BFS主题色：亮蓝色
                        execution: '#FFEB3B', // 执行高亮：黄色
                    },
                    fontFamily: {
                        mono: ['Consolas', 'Monaco', 'Courier New', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .hover-scale {
                @apply transition-transform duration-300 hover:scale-[1.02];
            }
            .category-bg {
                @apply bg-gradient-to-r from-primary/5 to-primary/10;
            }
            .subcategory-bg {
                @apply bg-gradient-to-r from-secondary/5 to-secondary/10;
            }
            .bfs-bg {
                @apply bg-gradient-to-r from-bfs/5 to-bfs/10;
            }
            .card-shadow {
                @apply shadow-sm hover:shadow-md transition-shadow duration-300;
            }
            .nav-item {
                @apply text-gray-700 hover:text-primary transition-colors duration-200;
            }
            .topic-card {
                @apply bg-cardbg rounded-lg p-5 card-shadow hover-scale;
            }
            .subtopic-item {
                @apply bg-white rounded-md p-3 border border-gray-100 hover:border-primary/50 transition-all duration-200 cursor-pointer;
            }
            .topic-header {
                @apply text-xl font-bold text-primary mb-4 flex items-center;
            }
            .subtopic-header {
                @apply font-semibold text-secondary mb-3;
            }
            .bfs-header {
                @apply font-bold text-bfs mb-3;
            }
            .site-title {
                @apply text-2xl font-bold text-primary tracking-tight;
            }
            .code-block {
                @apply bg-gray-800 text-gray-100 rounded-lg p-4 overflow-x-auto my-4 text-sm font-mono;
            }
            .step-item {
                @apply p-3 rounded-md mb-2 border-l-4 border-bfs bg-bfs/5;
            }
            .step-number {
                @apply inline-block w-6 h-6 rounded-full bg-bfs text-white text-center mr-2 text-xs;
            }
            .bfs-node {
                @apply w-10 h-10 flex items-center justify-center rounded-full text-white font-bold transition-all duration-300 cursor-pointer z-10;
            }
            .bfs-node-unvisited {
                @apply bg-gray-300 text-gray-700 hover:bg-gray-400;
            }
            .bfs-node-visited {
                @apply bg-bfs;
            }
            .bfs-node-current {
                @apply bg-red-500 scale-125;
            }
            .bfs-node-path {
                @apply bg-green-500;
            }
            .bfs-edge {
                @apply stroke-gray-300 transition-all duration-500 stroke-2;
            }
            .bfs-edge-active {
                @apply stroke-bfs stroke-3;
            }
            .bfs-edge-path {
                @apply stroke-green-500 stroke-3;
            }
            .animation-controls {
                @apply flex flex-wrap gap-2 items-center my-4;
            }
            .animation-step {
                @apply bg-gray-100 p-3 rounded-lg mb-4;
            }
            .animation-progress {
                @apply w-full bg-gray-200 rounded-full h-2.5 mb-2;
            }
            .animation-progress-bar {
                @apply bg-bfs h-2.5 rounded-full transition-all duration-300;
            }
            .animation-status {
                @apply text-sm text-gray-600 my-2 p-2 bg-gray-50 rounded;
            }
            .code-line {
                @apply transition-all duration-300;
            }
            .code-line-highlight {
                @apply bg-execution/30 text-gray-900 font-medium;
            }
            .control-btn {
                @apply px-3 py-1.5 rounded-md text-sm transition-all duration-200 flex items-center justify-center;
            }
            .speed-control {
                @apply flex items-center bg-white border border-gray-300 rounded-md p-1;
            }
            .speed-btn {
                @apply px-2 py-1 rounded text-xs hover:bg-gray-100 transition-colors;
            }
            .speed-btn.active {
                @apply bg-bfs text-white;
            }
            .graph-selector {
                @apply mt-3 p-2 border border-gray-200 rounded-md bg-white;
            }
        }
    </style>
</head>
<body class="bg-darkbg text-gray-800 font-sans min-h-screen">
    <!-- 顶部导航栏 -->
    <header class="bg-white shadow-sm sticky top-0 z-50 transition-all duration-300" id="navbar">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <i class="fa fa-code text-primary text-3xl"></i>
                <h1 class="site-title">姚老师信奥网</h1>
            </div>
            <div class="hidden md:flex items-center space-x-6">
                <a href="#" class="nav-item">首页</a>
                <a href="#" class="nav-item">课程</a>
                <a href="#" class="nav-item">题库</a>
                <a href="#" class="nav-item">关于我们</a>
            </div>
            <div class="flex items-center space-x-4">
                <!-- 搜索框 -->
                <div class="relative hidden md:block">
                    <input type="text" id="search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-64 transition-all duration-300 focus:w-72">
                    <button id="search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary transition-colors">
                        <i class="fa fa-search"></i>
                    </button>
                </div>
                <div class="md:hidden">
                    <button class="text-gray-700 hover:text-primary transition-colors">
                        <i class="fa fa-bars text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
        <!-- 移动端搜索框 -->
        <div class="md:hidden px-4 pb-3">
            <div class="relative">
                <input type="text" id="mobile-search-input" placeholder="搜索算法、数据结构..." class="pl-10 pr-4 py-2 rounded-md bg-darkbg border border-gray-200 focus:outline-none focus:border-primary text-gray-700 w-full">
                <button id="mobile-search-button" class="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-primary">
                    <i class="fa fa-search"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- 面包屑导航 -->
    <div class="bg-white border-b border-gray-200 py-2">
        <div class="container mx-auto px-4">
            <nav class="flex text-sm" aria-label="Breadcrumb">
                <ol class="inline-flex items-center space-x-1 md:space-x-3">
                    <li class="inline-flex items-center">
                        <a href="#" class="text-gray-600 hover:text-primary transition-colors">
                            <i class="fa fa-home mr-1"></i>首页
                        </a>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary transition-colors">算法基础</a>
                        </div>
                    </li>
                    <li>
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <a href="#" class="text-gray-600 hover:text-primary transition-colors">搜索算法</a>
                        </div>
                    </li>
                    <li aria-current="page">
                        <div class="flex items-center">
                            <i class="fa fa-angle-right mx-2 text-gray-400"></i>
                            <span class="text-bfs font-medium">广度优先搜索(BFS)</span>
                        </div>
                    </li>
                </ol>
            </nav>
        </div>
    </div>

    <!-- 主要内容区 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 页面标题 -->
        <div class="bfs-bg rounded-lg p-6 mb-8 shadow-sm transform transition-all duration-500 hover:shadow-md">
            <div class="flex flex-col md:flex-row md:items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-bfs mb-2">广度优先搜索 (BFS)</h1>
                    <p class="text-gray-700">
                        广度优先搜索是一种图遍历算法，它按层次顺序访问节点，非常适合解决最短路径问题和层次遍历问题。
                        本页面将详细讲解BFS的原理、实现方法及在信息学奥赛中的典型应用。
                    </p>
                </div>
                <div class="mt-4 md:mt-0">
                    <div class="flex flex-wrap gap-3">
                        <a href="#concept" class="bg-bfs hover:bg-bfs/90 text-white px-4 py-2 rounded-md transition-all flex items-center shadow-sm hover:shadow">
                            <i class="fa fa-book mr-2"></i> 学习概念
                        </a>
                        <a href="#animation" class="bg-white border border-bfs text-bfs hover:bg-bfs/5 px-4 py-2 rounded-md transition-all flex items-center shadow-sm hover:shadow">
                            <i class="fa fa-play-circle mr-2"></i> 观看演示
                        </a>
                        <a href="#problems" class="bg-white border border-bfs text-bfs hover:bg-bfs/5 px-4 py-2 rounded-md transition-all flex items-center shadow-sm hover:shadow">
                            <i class="fa fa-list-alt mr-2"></i> 查看题目
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- BFS定义概述 -->
        <section id="concept" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-bfs mb-6 flex items-center">
                <i class="fa fa-info-circle mr-2"></i> BFS算法概述
            </h2>
            <div class="space-y-4">
                <div>
                    <h3 class="text-xl font-semibold mb-3">什么是广度优先搜索？</h3>
                    <p class="text-gray-700">
                        广度优先搜索（Breadth-First Search，简称BFS）是一种图形搜索算法。它的基本思想是：
                        从起始节点开始，先访问起始节点的所有邻接节点（第一层节点），然后按照同样的顺序访问
                        这些邻接节点的所有未访问邻接节点（第二层节点），以此类推，直到找到目标节点或遍历完所有节点。
                    </p>
                    <div class="bg-gray-50 p-4 rounded-lg mt-3 border border-gray-100">
                        <h4 class="font-semibold mb-2">BFS的主要特点：</h4>
                        <ul class="list-disc pl-5 space-y-2">
                            <li>按层次顺序遍历节点，先访问的节点其邻接节点也先被访问</li>
                            <li>通常使用队列（Queue）数据结构实现</li>
                            <li>找到的路径是从起点到终点的最短路径（在无权图中）</li>
                            <li>空间复杂度较高，需要存储大量中间节点</li>
                            <li>适合解决最短路径问题、连通性问题和层次遍历问题</li>
                        </ul>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold mb-3">BFS的基本步骤</h3>
                    <div class="space-y-3">
                        <div class="step-item transform transition-all duration-300 hover:translate-x-1">
                            <div class="flex items-center">
                                <span class="step-number">1</span>
                                <h4 class="font-medium">初始化</h4>
                            </div>
                            <p class="text-gray-700 ml-8">
                                创建一个队列，将起始节点加入队列，并标记为已访问。
                            </p>
                        </div>
                        <div class="step-item transform transition-all duration-300 hover:translate-x-1">
                            <div class="flex items-center">
                                <span class="step-number">2</span>
                                <h4 class="font-medium">处理队列</h4>
                            </div>
                            <p class="text-gray-700 ml-8">
                                当队列不为空时，取出队首节点并访问该节点。
                            </p>
                        </div>
                        <div class="step-item transform transition-all duration-300 hover:translate-x-1">
                            <div class="flex items-center">
                                <span class="step-number">3</span>
                                <h4 class="font-medium">扩展节点</h4>
                            </div>
                            <p class="text-gray-700 ml-8">
                                将当前节点的所有未访问邻接节点加入队列，并标记为已访问。
                            </p>
                        </div>
                        <div class="step-item transform transition-all duration-300 hover:translate-x-1">
                            <div class="flex items-center">
                                <span class="step-number">4</span>
                                <h4 class="font-medium">重复执行</h4>
                            </div>
                            <p class="text-gray-700 ml-8">
                                重复步骤2和步骤3，直到找到目标节点或队列为空（遍历完所有节点）。
                            </p>
                        </div>
                    </div>
                </div>

                <div class="mt-6 bg-white p-4 rounded-lg border border-gray-100 shadow-sm">
                    <h3 class="text-xl font-semibold mb-3 flex items-center">
                        <i class="fa fa-exchange text-bfs mr-2"></i> BFS与DFS的对比
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold text-bfs mb-2">广度优先搜索(BFS)</h4>
                            <ul class="list-disc pl-5 space-y-1 text-gray-700">
                                <li>使用队列(Queue)数据结构</li>
                                <li>按层次顺序访问节点</li>
                                <li>能找到最短路径(无权图)</li>
                                <li>空间复杂度较高</li>
                                <li>适合查找最短路径</li>
                                <li>不适合深度较大的图</li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="font-semibold text-red-500 mb-2">深度优先搜索(DFS)</h4>
                            <ul class="list-disc pl-5 space-y-1 text-gray-700">
                                <li>使用栈(Stack)或递归</li>
                                <li>沿一条路径深入搜索</li>
                                <li>不一定能找到最短路径</li>
                                <li>空间复杂度相对较低</li>
                                <li>适合检测环路、拓扑排序</li>
                                <li>可能陷入深度较大的路径</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- BFS动画演示 -->
        <section id="animation" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-bfs mb-6 flex items-center">
                <i class="fa fa-play-circle mr-2"></i> BFS执行过程演示
            </h2>
            
            <div class="space-y-6">
                <!-- BFS动画 -->
                <div class="bg-gray-50 p-4 rounded-lg border border-gray-100">
                    <h3 class="font-semibold text-lg mb-3">BFS搜索过程动态演示</h3>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-1">
                            <p class="text-gray-700 mb-4">
                                下面的动画展示了BFS从起点到终点的完整搜索过程，包括节点访问顺序、队列变化和最短路径生成。
                                左侧为图结构，中间为算法执行过程，右侧为代码及执行高亮。
                            </p>
                            
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">选择起点和终点:</label>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label class="text-xs text-gray-500 mb-1 block">起点</label>
                                        <select id="start-node" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-bfs focus:ring-1 focus:ring-bfs transition-all">
                                            <option value="A">A</option>
                                            <option value="B">B</option>
                                            <option value="C">C</option>
                                            <option value="D">D</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="text-xs text-gray-500 mb-1 block">终点</label>
                                        <select id="end-node" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:border-bfs focus:ring-1 focus:ring-bfs transition-all">
                                            <option value="A">A</option>
                                            <option value="B">B</option>
                                            <option value="C">C</option>
                                            <option value="D" selected>D</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <!-- 图结构选择器 -->
                            <div class="graph-selector">
                                <label class="block text-xs text-gray-500 mb-1">选择图结构:</label>
                                <select id="graph-type" class="w-full px-2 py-1.5 text-sm border border-gray-200 rounded focus:outline-none focus:border-bfs">
                                    <option value="simple">简单图 (4节点)</option>
                                    <option value="chain">链式图</option>
                                    <option value="tree">树状图</option>
                                </select>
                            </div>
                            
                            <div class="flex flex-wrap gap-2 mt-4">
                                <button id="bfs-run" class="control-btn bg-bfs hover:bg-bfs/90 text-white shadow-sm">
                                    <i class="fa fa-play mr-1.5"></i> 运行
                                </button>
                                <button id="bfs-pause" class="control-btn bg-gray-200 hover:bg-gray-300 text-gray-700 shadow-sm hidden">
                                    <i class="fa fa-pause mr-1.5"></i> 暂停
                                </button>
                                <button id="bfs-step" class="control-btn bg-blue-100 hover:bg-blue-200 text-blue-800 shadow-sm">
                                    <i class="fa fa-step-forward mr-1.5"></i> 单步
                                </button>
                                <button id="bfs-reset" class="control-btn bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 shadow-sm">
                                    <i class="fa fa-refresh mr-1.5"></i> 重置
                                </button>
                            </div>

                            <!-- 速度控制 -->
                            <div class="mt-4">
                                <label class="block text-xs text-gray-500 mb-1">动画速度:</label>
                                <div class="speed-control">
                                    <button class="speed-btn active" data-speed="500">快</button>
                                    <button class="speed-btn" data-speed="1000">中</button>
                                    <button class="speed-btn" data-speed="2000">慢</button>
                                    <button class="speed-btn" data-speed="3000">极慢</button>
                                </div>
                            </div>
                            
                            <div class="animation-progress mt-4">
                                <div id="bfs-progress-bar" class="animation-progress-bar" style="width: 0%"></div>
                            </div>
                            
                            <div id="bfs-status" class="animation-status">
                                状态: 等待开始
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="bg-white border border-gray-200 rounded-lg p-4 h-64 overflow-y-auto" id="bfs-execution">
                                <div class="text-center text-gray-500 py-8">
                                    <i class="fa fa-arrow-down mb-2"></i>
                                    <p>点击"运行"或"单步"开始演示</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="lg:col-span-1">
                            <div class="flex items-center justify-between mb-2">
                                <h4 class="font-medium text-gray-700 text-sm">BFS算法代码</h4>
                                <button id="copy-code" class="text-xs text-gray-500 hover:text-primary transition-colors">
                                    <i class="fa fa-copy mr-1"></i> 复制代码
                                </button>
                            </div>
                            <div class="bg-gray-800 text-gray-100 rounded-lg p-4 h-64 overflow-y-auto font-mono text-sm" id="bfs-code">
                                <div class="code-line" id="code-1">#include &lt;iostream&gt;</div>
                                <div class="code-line" id="code-2">#include &lt;queue&gt;</div>
                                <div class="code-line" id="code-3">#include &lt;vector&gt;</div>
                                <div class="code-line" id="code-4">#include &lt;map&gt;</div>
                                <div class="code-line" id="code-5">using namespace std;</div>
                                <div class="code-line" id="code-6">&nbsp;</div>
                                <div class="code-line" id="code-7">// BFS函数，返回从start到end的最短路径</div>
                                <div class="code-line" id="code-8">vector<char> bfs(map<char, vector<char>>& graph, char start, char end) {</div>
                                <div class="code-line" id="code-9">&nbsp;&nbsp;queue<char> q;</div>
                                <div class="code-line" id="code-10">&nbsp;&nbsp;map<char, bool> visited;</div>
                                <div class="code-line" id="code-11">&nbsp;&nbsp;map<char, char> parent;</div>
                                <div class="code-line" id="code-12">&nbsp;&nbsp;</div>
                                <div class="code-line" id="code-13">&nbsp;&nbsp;// 初始化</div>
                                <div class="code-line" id="code-14">&nbsp;&nbsp;q.push(start);</div>
                                <div class="code-line" id="code-15">&nbsp;&nbsp;visited[start] = true;</div>
                                <div class="code-line" id="code-16">&nbsp;&nbsp;parent[start] = ' ';</div>
                                <div class="code-line" id="code-17">&nbsp;&nbsp;</div>
                                <div class="code-line" id="code-18">&nbsp;&nbsp;// 队列不为空时循环</div>
                                <div class="code-line" id="code-19">&nbsp;&nbsp;while (!q.empty()) {</div>
                                <div class="code-line" id="code-20">&nbsp;&nbsp;&nbsp;&nbsp;char current = q.front();</div>
                                <div class="code-line" id="code-21">&nbsp;&nbsp;&nbsp;&nbsp;q.pop();</div>
                                <div class="code-line" id="code-22">&nbsp;&nbsp;&nbsp;&nbsp;</div>
                                <div class="code-line" id="code-23">&nbsp;&nbsp;&nbsp;&nbsp;// 找到终点，退出循环</div>
                                <div class="code-line" id="code-24">&nbsp;&nbsp;&nbsp;&nbsp;if (current == end) {</div>
                                <div class="code-line" id="code-25">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div>
                                <div class="code-line" id="code-26">&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="code-27">&nbsp;&nbsp;&nbsp;&nbsp;</div>
                                <div class="code-line" id="code-28">&nbsp;&nbsp;&nbsp;&nbsp;// 访问所有邻接节点</div>
                                <div class="code-line" id="code-29">&nbsp;&nbsp;&nbsp;&nbsp;for (char neighbor : graph[current]) {</div>
                                <div class="code-line" id="code-30">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!visited[neighbor]) {</div>
                                <div class="code-line" id="code-31">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.push(neighbor);</div>
                                <div class="code-line" id="code-32">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited[neighbor] = true;</div>
                                <div class="code-line" id="code-33">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent[neighbor] = current;</div>
                                <div class="code-line" id="code-34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="code-35">&nbsp;&nbsp;&nbsp;&nbsp;}</div>
                                <div class="code-line" id="code-36">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="code-37">&nbsp;&nbsp;</div>
                                <div class="code-line" id="code-38">&nbsp;&nbsp;// 重建路径</div>
                                <div class="code-line" id="code-39">&nbsp;&nbsp;vector<char> path;</div>
                                <div class="code-line" id="code-40">&nbsp;&nbsp;char curr = end;</div>
                                <div class="code-line" id="code-41">&nbsp;&nbsp;</div>
                                <div class="code-line" id="code-42">&nbsp;&nbsp;while (curr != ' ') {</div>
                                <div class="code-line" id="code-43">&nbsp;&nbsp;&nbsp;&nbsp;path.push_back(curr);</div>
                                <div class="code-line" id="code-44">&nbsp;&nbsp;&nbsp;&nbsp;curr = parent[curr];</div>
                                <div class="code-line" id="code-45">&nbsp;&nbsp;}</div>
                                <div class="code-line" id="code-46">&nbsp;&nbsp;</div>
                                <div class="code-line" id="code-47">&nbsp;&nbsp;reverse(path.begin(), path.end());</div>
                                <div class="code-line" id="code-48">&nbsp;&nbsp;return path;</div>
                                <div class="code-line" id="code-49">}</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 图形展示区域 -->
                    <div class="mt-6 flex justify-center">
                        <div id="graph-container" class="relative w-full max-w-2xl h-80 border border-gray-200 rounded-lg bg-white p-4">
                            <!-- 节点和边将通过JavaScript动态生成 -->
                        </div>
                    </div>
                    
                    <!-- 队列展示 -->
                    <div class="mt-4 bg-white p-3 rounded-lg border border-gray-200">
                        <h4 class="font-medium text-gray-700 mb-2 flex items-center">
                            <i class="fa fa-list-ol text-bfs mr-2"></i>队列状态
                        </h4>
                        <div id="queue-status" class="flex flex-wrap gap-2 min-h-[40px]">
                            <div class="text-gray-500 italic">队列是空的</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- BFS算法实现 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-bfs mb-6 flex items-center">
                <i class="fa fa-code mr-2"></i> BFS算法实现 (C++)
            </h2>
            
            <div class="space-y-6">
                <!-- 基础BFS示例 -->
                <div class="bg-gray-50 p-4 rounded-lg border border-gray-100">
                    <h3 class="font-semibold text-lg mb-3">1. 基础BFS实现 - 图的遍历</h3>
                    <p class="text-gray-700 mb-3">
                        使用邻接表表示图，实现BFS遍历并输出访问顺序
                    </p>
                    
                    <div class="flex justify-end mb-2">
                        <button class="copy-btn text-xs text-gray-500 hover:text-primary transition-colors" data-target="code-block-1">
                            <i class="fa fa-copy mr-1"></i> 复制代码
                        </button>
                    </div>
                    <pre class="code-block" id="code-block-1"><code class="language-cpp">#include <iostream>
#include <queue>
#include <vector>
#include <cstring>
using namespace std;

// 图的邻接表表示
vector<int> adj[100];
// 记录节点是否被访问
bool visited[100];

// BFS函数
void bfs(int start) {
    // 创建队列
    queue<int> q;
    
    // 初始化：将起点加入队列并标记为已访问
    q.push(start);
    visited[start] = true;
    
    cout << "BFS访问顺序: ";
    
    // 队列不为空时循环
    while (!q.empty()) {
        // 取出队首节点
        int current = q.front();
        q.pop();
        
        // 访问当前节点
        cout << current << " ";
        
        // 将所有未访问的邻接节点加入队列
        for (int neighbor : adj[current]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
    cout << endl;
}

int main() {
    int n, m;
    cout << "输入节点数和边数: ";
    cin >> n >> m;
    
    // 初始化访问标记
    memset(visited, false, sizeof(visited));
    
    // 读入边
    cout << "输入" << m << "条边: " << endl;
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u); // 无向图
    }
    
    int start;
    cout << "输入起始节点: ";
    cin >> start;
    
    // 执行BFS
    bfs(start);
    
    return 0;
}</code></pre>
                </div>
                
                <!-- 二维网格BFS示例 -->
                <div class="bg-gray-50 p-4 rounded-lg border border-gray-100">
                    <h3 class="font-semibold text-lg mb-3">2. 网格最短路径 - 迷宫问题</h3>
                    <p class="text-gray-700 mb-3">
                        使用BFS求解迷宫最短路径问题，0表示可走，1表示障碍物
                    </p>
                    
                    <div class="flex justify-end mb-2">
                        <button class="copy-btn text-xs text-gray-500 hover:text-primary transition-colors" data-target="code-block-2">
                            <i class="fa fa-copy mr-1"></i> 复制代码
                        </button>
                    </div>
                    <pre class="code-block" id="code-block-2"><code class="language-cpp">#include <iostream>
#include <queue>
#include <vector>
using namespace std;

// 方向数组：上、右、下、左
int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};

// 迷宫大小
const int MAX_N = 100;
const int MAX_M = 100;

// 迷宫数据
int maze[MAX_N][MAX_M];
// 记录距离
int dist[MAX_N][MAX_M];
// 记录是否访问过
bool visited[MAX_N][MAX_M];

// 起点和终点
int start_x, start_y, end_x, end_y;
int n, m;

// BFS求解最短路径
int bfs() {
    // 初始化队列
    queue<pair<int, int>> q;
    
    // 初始化距离为-1（不可达）
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            dist[i][j] = -1;
            visited[i][j] = false;
        }
    }
    
    // 起点入队
    q.push({start_x, start_y});
    visited[start_x][start_y] = true;
    dist[start_x][start_y] = 0;
    
    // 队列不为空时循环
    while (!q.empty()) {
        // 取出队首元素
        auto current = q.front();
        q.pop();
        int x = current.first;
        int y = current.second;
        
        // 如果到达终点，返回距离
        if (x == end_x && y == end_y) {
            return dist[x][y];
        }
        
        // 探索四个方向
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            
            // 检查新位置是否合法
            if (nx >= 0 && nx < n && ny >= 0 && ny < m 
                && maze[nx][ny] == 0 && !visited[nx][ny]) {
                // 合法则加入队列
                q.push({nx, ny});
                visited[nx][ny] = true;
                dist[nx][ny] = dist[x][y] + 1;
            }
        }
    }
    
    // 无法到达终点
    return -1;
}

int main() {
    cout << "输入迷宫大小(n m): ";
    cin >> n >> m;
    
    cout << "输入迷宫: " << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> maze[i][j];
        }
    }
    
    cout << "输入起点坐标(x y): ";
    cin >> start_x >> start_y;
    
    cout << "输入终点坐标(x y): ";
    cin >> end_x >> end_y;
    
    // 检查起点和终点是否合法
    if (maze[start_x][start_y] == 1 || maze[end_x][end_y] == 1) {
        cout << "起点或终点是障碍物，无法到达！" << endl;
        return 0;
    }
    
    int shortest_dist = bfs();
    
    if (shortest_dist == -1) {
        cout << "无法从起点到达终点！" << endl;
    } else {
        cout << "最短路径长度为: " << shortest_dist << endl;
    }
    
    return 0;
}</code></pre>
                </div>
                
                <!-- BFS层次遍历示例 -->
                <div class="bg-gray-50 p-4 rounded-lg border border-gray-100">
                    <h3 class="font-semibold text-lg mb-3">3. 二叉树层次遍历</h3>
                    <p class="text-gray-700 mb-3">
                        使用BFS实现二叉树的层次遍历，按层次输出节点值
                    </p>
                    
                    <div class="flex justify-end mb-2">
                        <button class="copy-btn text-xs text-gray-500 hover:text-primary transition-colors" data-target="code-block-3">
                            <i class="fa fa-copy mr-1"></i> 复制代码
                        </button>
                    </div>
                    <pre class="code-block" id="code-block-3"><code class="language-cpp">#include <iostream>
#include <queue>
#include <vector>
using namespace std;

// 二叉树节点结构
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// 层次遍历函数
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (root == NULL) return result;
    
    // 创建队列，存储每一层的节点
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        // 当前层的节点数量
        int level_size = q.size();
        vector<int> current_level;
        
        // 遍历当前层的所有节点
        for (int i = 0; i < level_size; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            // 记录当前节点值
            current_level.push_back(node->val);
            
            // 将子节点加入队列
            if (node->left != NULL) {
                q.push(node->left);
            }
            if (node->right != NULL) {
                q.push(node->right);
            }
        }
        
        // 将当前层的节点值加入结果
        result.push_back(current_level);
    }
    
    return result;
}

// 辅助函数：创建二叉树
TreeNode* createTree() {
    int val;
    cin >> val;
    if (val == -1) { // 用-1表示空节点
        return NULL;
    }
    
    TreeNode* root = new TreeNode(val);
    root->left = createTree();
    root->right = createTree();
    
    return root;
}

int main() {
    cout << "按先序遍历输入二叉树节点值(-1表示空节点):" << endl;
    TreeNode* root = createTree();
    
    vector<vector<int>> levels = levelOrder(root);
    
    cout << "层次遍历结果:" << endl;
    for (auto& level : levels) {
        for (int val : level) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    return 0;
}</code></pre>
                </div>

                <!-- BFS变种算法 -->
                <div class="bg-gray-50 p-4 rounded-lg border border-gray-100">
                    <h3 class="font-semibold text-lg mb-3">4. BFS变种算法 - 双向BFS</h3>
                    <p class="text-gray-700 mb-3">
                        双向BFS从起点和终点同时开始搜索，相遇时找到最短路径，效率更高
                    </p>
                    
                    <div class="flex justify-end mb-2">
                        <button class="copy-btn text-xs text-gray-500 hover:text-primary transition-colors" data-target="code-block-4">
                            <i class="fa fa-copy mr-1"></i> 复制代码
                        </button>
                    </div>
                    <pre class="code-block" id="code-block-4"><code class="language-cpp">#include <iostream>
#include <queue>
#include <unordered_set>
#include <vector>
#include <map>
using namespace std;

// 双向BFS寻找最短路径
int bidirectionalBFS(map<char, vector<char>>& graph, char start, char end) {
    // 起点和终点相同
    if (start == end) return 0;
    
    // 两个方向的队列
    queue<char> qStart, qEnd;
    // 记录访问过的节点及距离
    map<char, int> distStart, distEnd;
    // 记录已访问节点
    unordered_set<char> visitedStart, visitedEnd;
    
    // 初始化
    qStart.push(start);
    visitedStart.insert(start);
    distStart[start] = 0;
    
    qEnd.push(end);
    visitedEnd.insert(end);
    distEnd[end] = 0;
    
    // 双向BFS主循环
    while (!qStart.empty() && !qEnd.empty()) {
        // 从起点方向搜索一步
        int sizeStart = qStart.size();
        for (int i = 0; i < sizeStart; i++) {
            char current = qStart.front();
            qStart.pop();
            
            // 检查是否与另一端相遇
            if (visitedEnd.count(current)) {
                return distStart[current] + distEnd[current];
            }
            
            // 扩展邻居节点
            for (char neighbor : graph[current]) {
                if (!visitedStart.count(neighbor)) {
                    visitedStart.insert(neighbor);
                    distStart[neighbor] = distStart[current] + 1;
                    qStart.push(neighbor);
                }
            }
        }
        
        // 从终点方向搜索一步
        int sizeEnd = qEnd.size();
        for (int i = 0; i < sizeEnd; i++) {
            char current = qEnd.front();
            qEnd.pop();
            
            // 检查是否与另一端相遇
            if (visitedStart.count(current)) {
                return distStart[current] + distEnd[current];
            }
            
            // 扩展邻居节点
            for (char neighbor : graph[current]) {
                if (!visitedEnd.count(neighbor)) {
                    visitedEnd.insert(neighbor);
                    distEnd[neighbor] = distEnd[current] + 1;
                    qEnd.push(neighbor);
                }
            }
        }
    }
    
    // 无法到达
    return -1;
}

int main() {
    // 构建图
    map<char, vector<char>> graph = {
        {'A', {'B', 'C'}},
        {'B', {'A', 'D', 'E'}},
        {'C', {'A', 'F'}},
        {'D', {'B'}},
        {'E', {'B', 'F'}},
        {'F', {'C', 'E'}}
    };
    
    char start = 'A', end = 'F';
    int shortestDistance = bidirectionalBFS(graph, start, end);
    
    if (shortestDistance == -1) {
        cout << "从" << start << "到" << end << "没有路径！" << endl;
    } else {
        cout << "从" << start << "到" << end << "的最短路径长度为: " << shortestDistance << endl;
    }
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- BFS算法应用 -->
        <section class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-bfs mb-6 flex items-center">
                <i class="fa fa-lightbulb-o mr-2"></i> BFS的算法应用
            </h2>
            
            <div class="space-y-6">
                <div>
                    <h3 class="text-xl font-semibold mb-3">BFS在信息学奥赛中的典型应用</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-100 transform transition-all duration-300 hover:shadow-sm">
                            <h4 class="font-semibold text-bfs mb-2 flex items-center">
                                <i class="fa fa-road mr-2"></i>最短路径问题
                            </h4>
                            <p class="text-gray-700">
                                在无权图或权值相同的图中，BFS可以高效地找到两点之间的最短路径，如迷宫问题、城市路径规划等。
                            </p>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-100 transform transition-all duration-300 hover:shadow-sm">
                            <h4 class="font-semibold text-bfs mb-2 flex items-center">
                                <i class="fa fa-link mr-2"></i>连通性问题
                            </h4>
                            <p class="text-gray-700">
                                判断图中两点是否连通，或者计算图中的连通分量数量，如岛屿数量问题、网络连接判断等。
                            </p>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-100 transform transition-all duration-300 hover:shadow-sm">
                            <h4 class="font-semibold text-bfs mb-2 flex items-center">
                                <i class="fa fa-sitemap mr-2"></i>层次遍历
                            </h4>
                            <p class="text-gray-700">
                                按层次顺序遍历树或图的节点，如二叉树的层次遍历、多叉树的层级访问等。
                            </p>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-100 transform transition-all duration-300 hover:shadow-sm">
                            <h4 class="font-semibold text-bfs mb-2 flex items-center">
                                <i class="fa fa-rocket mr-2"></i>广度优先搜索优化
                            </h4>
                            <p class="text-gray-700">
                                结合启发式信息的BFS变种算法，如双向BFS、0-1BFS等，可以解决更复杂的搜索问题。
                            </p>
                        </div>
                    </div>
                </div>

                <!-- BFS应用案例 -->
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-4">BFS实际应用案例</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-white rounded-lg overflow-hidden">
                            <thead class="bg-gray-50 border-b">
                                <tr>
                                    <th class="py-3 px-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">应用场景</th>
                                    <th class="py-3 px-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">BFS的作用</th>
                                    <th class="py-3 px-4 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">典型问题</th>
                                </tr>
                            </thead>
                            <tbody class="divide-y divide-gray-100">
                                <tr class="hover:bg-gray-50 transition-colors">
                                    <td class="py-3 px-4">社交网络分析</td>
                                    <td class="py-3 px-4">查找两人之间的最短社交链（六度分隔理论）</td>
                                    <td class="py-3 px-4">朋友推荐、关系链分析</td>
                                </tr>
                                <tr class="hover:bg-gray-50 transition-colors">
                                    <td class="py-3 px-4">地图导航</td>
                                    <td class="py-3 px-4">在无权图中寻找两点间最短路径</td>
                                    <td class="py-3 px-4">最短路线规划、最少换乘次数</td>
                                </tr>
                                <tr class="hover:bg-gray-50 transition-colors">
                                    <td class="py-3 px-4">网络爬虫</td>
                                    <td class="py-3 px-4">按层次遍历网页，实现广度优先爬取</td>
                                    <td class="py-3 px-4">网站内容索引、链接分析</td>
                                </tr>
                                <tr class="hover:bg-gray-50 transition-colors">
                                    <td class="py-3 px-4">电路设计</td>
                                    <td class="py-3 px-4">检测电路连接、寻找最短路径</td>
                                    <td class="py-3 px-4">故障检测、信号传输路径分析</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- 推荐题目 -->
        <section id="problems" class="topic-card mb-8">
            <h2 class="text-2xl font-bold text-bfs mb-6 flex items-center">
                <i class="fa fa-trophy mr-2"></i> 推荐练习题目 (洛谷)
            </h2>
            
            <div class="space-y-6">
                <!-- 模板题 -->
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary flex items-center">
                        <i class="fa fa-graduation-cap mr-2"></i>模板题
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1443 马的遍历</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                给定一个n*m的棋盘，以及马的起始位置，要求计算马到达棋盘上每个点的最少步数。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1443" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P5318 【深基18.例3】查找文献</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                给定一个无向图，输出从1号节点开始的BFS遍历顺序和DFS遍历顺序。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P5318" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P2895 [USACO08FEB] Hotel G</h4>
                                <span class="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded">普及/提高-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                一个有N个房间的酒店，从1到N编号，计算从房间1到房间N的最短路径。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P2895" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
                
                <!-- 入门题 -->
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary flex items-center">
                        <i class="fa fa-signal mr-2"></i>入门题
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1162 填涂颜色</h4>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                给定一个方阵，其中0表示白色，1表示黑色，将被黑色包围的白色区域填充为黑色。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1162" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1332 血色先锋队</h4>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">普及/提高-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                给定一个城市地图，计算每个健康的居民被感染的最早时间。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1332" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1596 [USACO10OCT] Lake Counting S</h4>
                                <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">普及-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                一个农场地图，计算有多少个独立的池塘，八连通的水域被视为一个池塘。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1596" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
                
                <!-- 进阶题 -->
                <div>
                    <h3 class="text-xl font-semibold mb-4 text-primary flex items-center">
                        <i class="fa fa-fire mr-2"></i>进阶题
                    </h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P1141 01迷宫</h4>
                                <span class="bg-yellow-100 text-yellow-800 text-xs px-2 py-1 rounded">普及+/提高</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                给定一个01迷宫，每次可以向相邻的与当前格子值不同的格子移动，计算每个格子所在连通块的大小。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P1141" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P2661 信息传递</h4>
                                <span class="bg-yellow-100 text-yellow-800 text-xs px-2 py-1 rounded">普及+/提高</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                有n个同学，每个同学都有一个信息传递对象，求最小的传递环的长度。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P2661" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                        
                        <div class="bg-white border border-gray-200 rounded-lg p-4 hover-scale">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold">P3959 宝藏</h4>
                                <span class="bg-red-100 text-red-800 text-xs px-2 py-1 rounded">提高+/省选-</span>
                            </div>
                            <p class="text-gray-600 text-sm mb-3">
                                在一个无向图中，选择一个起点建造宝藏，按一定规则开采其他节点，求最小代价。
                            </p>
                            <a href="https://www.luogu.com.cn/problem/P3959" target="_blank" class="text-bfs hover:text-bfs/80 text-sm flex items-center">
                                查看题目 <i class="fa fa-external-link ml-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-white border-t border-gray-200 py-6">
        <div class="container mx-auto px-4">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-4 md:mb-0">
                    <div class="flex items-center space-x-2">
                        <i class="fa fa-code text-primary text-xl"></i>
                        <span class="font-bold text-gray-800">姚老师信奥网</span>
                    </div>
                    <p class="text-sm text-gray-500 mt-1">专注于信息学奥林匹克竞赛教学</p>
                </div>
                <div class="flex space-x-6">
                    <a href="#" class="text-gray-500 hover:text-primary transition-colors">
                        <i class="fa fa-github text-xl"></i>
                    </a>
                    <a href="#" class="text-gray-500 hover:text-primary transition-colors">
                        <i class="fa fa-twitter text-xl"></i>
                    </a>
                    <a href="#" class="text-gray-500 hover:text-primary transition-colors">
                        <i class="fa fa-envelope text-xl"></i>
                    </a>
                </div>
            </div>
            <div class="mt-6 text-center text-sm text-gray-500">
                &copy; 2023 姚老师信奥网 - 版权所有
            </div>
        </div>
    </footer>

    <script>
        // 初始化代码高亮
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
            
            // 导航栏滚动效果
            const navbar = document.getElementById('navbar');
            window.addEventListener('scroll', function() {
                if (window.scrollY > 10) {
                    navbar.classList.add('shadow');
                } else {
                    navbar.classList.remove('shadow');
                }
            });
            
            // 图的定义 - 支持多种图结构
            const graphs = {
                simple: {
                    nodes: ['A', 'B', 'C', 'D'],
                    edges: [
                        ['A', 'B'], ['A', 'C'], ['A', 'D'],
                        ['B', 'D'], ['C', 'D']
                    ],
                    positions: {
                        'A': { top: '25%', left: '25%' },
                        'B': { top: '25%', left: '75%' },
                        'C': { top: '75%', left: '33%' },
                        'D': { top: '75%', left: '67%' }
                    }
                },
                chain: {
                    nodes: ['A', 'B', 'C', 'D', 'E'],
                    edges: [
                        ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'E']
                    ],
                    positions: {
                        'A': { top: '50%', left: '10%' },
                        'B': { top: '50%', left: '30%' },
                        'C': { top: '50%', left: '50%' },
                        'D': { top: '50%', left: '70%' },
                        'E': { top: '50%', left: '90%' }
                    }
                },
                tree: {
                    nodes: ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
                    edges: [
                        ['A', 'B'], ['A', 'C'],
                        ['B', 'D'], ['B', 'E'],
                        ['C', 'F'], ['C', 'G']
                    ],
                    positions: {
                        'A': { top: '15%', left: '50%' },
                        'B': { top: '40%', left: '30%' },
                        'C': { top: '40%', left: '70%' },
                        'D': { top: '65%', left: '20%' },
                        'E': { top: '65%', left: '40%' },
                        'F': { top: '65%', left: '60%' },
                        'G': { top: '65%', left: '80%' }
                    }
                }
            };
            
            // 当前使用的图
            let currentGraph = 'simple';
            
            // 生成图函数
            function generateGraph(graphType) {
                const graph = graphs[graphType];
                const container = document.getElementById('graph-container');
                container.innerHTML = '';
                
                // 创建SVG用于绘制边
                // 创建SVG用于绘制边
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'absolute inset-0 w-full h-full');
                svg.style.zIndex = '0';
                container.appendChild(svg);
                
                // 创建节点
                graph.nodes.forEach(nodeId => {
                    const node = document.createElement('div');
                    const pos = graph.positions[nodeId];
                    node.className = 'bfs-node bfs-node-unvisited absolute';
                    node.style.top = pos.top;
                    node.style.left = pos.left;
                    node.setAttribute('data-node', nodeId);
                    node.textContent = nodeId;
                    container.appendChild(node);
                });
                
                // 创建边
                graph.edges.forEach(edge => {
                    const [from, to] = edge;
                    const fromNode = document.querySelector(`.bfs-node[data-node="${from}"]`);
                    const toNode = document.querySelector(`.bfs-node[data-node="${to}"]`);
                    
                    if (fromNode && toNode) {
                        const fromRect = fromNode.getBoundingClientRect();
                        const toRect = toNode.getBoundingClientRect();
                        const containerRect = container.getBoundingClientRect();
                        
                        // 计算相对于容器的百分比位置
                        const x1 = ((fromRect.left + fromRect.width/2 - containerRect.left) / containerRect.width) * 100;
                        const y1 = ((fromRect.top + fromRect.height/2 - containerRect.top) / containerRect.height) * 100;
                        const x2 = ((toRect.left + toRect.width/2 - containerRect.left) / containerRect.width) * 100;
                        const y2 = ((toRect.top + toRect.height/2 - containerRect.top) / containerRect.height) * 100;
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', `${x1}%`);
                        line.setAttribute('y1', `${y1}%`);
                        line.setAttribute('x2', `${x2}%`);
                        line.setAttribute('y2', `${y2}%`);
                        line.setAttribute('class', 'bfs-edge');
                        line.setAttribute('data-from', from);
                        line.setAttribute('data-to', to);
                        svg.appendChild(line);
                    }
                });
                
                // 更新起点和终点选择器
                const startSelect = document.getElementById('start-node');
                const endSelect = document.getElementById('end-node');
                
                // 保存当前选中值
                const currentStart = startSelect.value;
                const currentEnd = endSelect.value;
                
                // 清空选择器
                startSelect.innerHTML = '';
                endSelect.innerHTML = '';
                
                // 添加新选项
                graph.nodes.forEach(nodeId => {
                    const startOption = document.createElement('option');
                    startOption.value = nodeId;
                    startOption.textContent = nodeId;
                    if (nodeId === currentStart || (startSelect.options.length === 0 && nodeId === graph.nodes[0])) {
                        startOption.selected = true;
                    }
                    startSelect.appendChild(startOption);
                    
                    const endOption = document.createElement('option');
                    endOption.value = nodeId;
                    endOption.textContent = nodeId;
                    if (nodeId === currentEnd || (endSelect.options.length === 0 && nodeId === graph.nodes[graph.nodes.length - 1])) {
                        endOption.selected = true;
                    }
                    endSelect.appendChild(endOption);
                });
            }
            
            // 初始生成图
            generateGraph(currentGraph);
            
            // 图类型选择事件
            document.getElementById('graph-type').addEventListener('change', function() {
                currentGraph = this.value;
                resetAnimation();
                generateGraph(currentGraph);
            });
            
            // 获取当前图的邻接表
            function getGraphAdjacencyList() {
                const graph = graphs[currentGraph];
                const adjList = {};
                
                graph.nodes.forEach(node => {
                    adjList[node] = [];
                });
                
                graph.edges.forEach(edge => {
                    const [from, to] = edge;
                    adjList[from].push(to);
                    adjList[to].push(from);
                });
                
                return adjList;
            }
            
            // BFS动画步骤
            const steps = [];
            let currentStep = 0;
            let animationInterval;
            let animationSpeed = 1000; // 默认中等速度
            
            // 重置函数
            function resetAnimation() {
                // 停止动画
                clearInterval(animationInterval);
                
                // 重置按钮状态
                document.getElementById('bfs-run').classList.remove('hidden');
                document.getElementById('bfs-pause').classList.add('hidden');
                
                // 重置节点状态
                document.querySelectorAll('.bfs-node').forEach(node => {
                    node.className = 'bfs-node bfs-node-unvisited absolute';
                    // 恢复原始位置
                    const id = node.getAttribute('data-node');
                    const pos = graphs[currentGraph].positions[id];
                    node.style.top = pos.top;
                    node.style.left = pos.left;
                });
                
                // 重置边状态
                document.querySelectorAll('.bfs-edge').forEach(edge => {
                    edge.className = 'bfs-edge';
                });
                
                // 重置队列显示
                document.getElementById('queue-status').innerHTML = '<div class="text-gray-500 italic">队列是空的</div>';
                
                // 重置代码高亮
                document.querySelectorAll('.code-line').forEach(line => {
                    line.classList.remove('code-line-highlight');
                });
                
                // 重置状态
                document.getElementById('bfs-status').textContent = '状态: 等待开始';
                document.getElementById('bfs-progress-bar').style.width = '0%';
                document.getElementById('bfs-execution').innerHTML = `
                    <div class="text-center text-gray-500 py-8">
                        <i class="fa fa-arrow-down mb-2"></i>
                        <p>点击"运行"或"单步"开始演示</p>
                    </div>
                `;
                
                // 重置步骤
                currentStep = 0;
                steps.length = 0;
            }
            
            // 生成BFS步骤
            function generateSteps(start, end) {
                steps.length = 0;
                const graph = getGraphAdjacencyList();
                const visited = new Set();
                const queue = [start];
                const parent = {};
                parent[start] = null;
                visited.add(start);
                
                // 添加初始化步骤
                steps.push({
                    type: 'init',
                    queue: [start],
                    current: null,
                    visited: [start],
                    message: `初始化：将起点${start}加入队列并标记为已访问`,
                    codeLine: 14
                });
                
                let found = false;
                
                while (queue.length > 0 && !found) {
                    const current = queue.shift();
                    
                    // 添加处理当前节点步骤
                    steps.push({
                        type: 'process',
                        queue: [...queue],
                        current: current,
                        visited: [...visited],
                        message: `处理节点${current}：从队列中取出并访问`,
                        codeLine: 20
                    });
                    
                    // 如果找到终点，退出
                    if (current === end) {
                        found = true;
                        break;
                    }
                    
                    // 处理邻居节点
                    for (const neighbor of graph[current]) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                            parent[neighbor] = current;
                            
                            // 添加发现邻居步骤
                            steps.push({
                                type: 'discover',
                                queue: [...queue],
                                current: current,
                                neighbor: neighbor,
                                visited: [...visited],
                                message: `发现未访问节点${neighbor}：将其加入队列并标记为已访问`,
                                codeLine: 31
                            });
                        }
                    }
                }
                
                // 如果找到终点，添加路径步骤
                if (found) {
                    // 重建路径
                    const path = [];
                    let curr = end;
                    while (curr !== null) {
                        path.unshift(curr);
                        curr = parent[curr];
                    }
                    
                    steps.push({
                        type: 'found',
                        queue: [...queue],
                        current: end,
                        visited: [...visited],
                        path: path,
                        message: `找到终点${end}！最短路径为: ${path.join(' -> ')}`,
                        codeLine: 24
                    });
                } else {
                    steps.push({
                        type: 'notfound',
                        queue: [...queue],
                        visited: [...visited],
                        message: `未找到终点${end}，图中不存在从${start}到${end}的路径`,
                        codeLine: -1
                    });
                }
            }
            
            // 执行单个步骤
            function executeStep(step) {
                // 重置所有高亮
                document.querySelectorAll('.bfs-node').forEach(node => {
                    node.classList.remove('bfs-node-current');
                });
                document.querySelectorAll('.bfs-edge').forEach(edge => {
                    edge.classList.remove('bfs-edge-active', 'bfs-edge-path');
                    edge.classList.add('bfs-edge');
                });
                document.querySelectorAll('.code-line').forEach(line => {
                    line.classList.remove('code-line-highlight');
                });
                
                // 更新状态信息
                document.getElementById('bfs-status').textContent = `状态: ${step.message}`;
                
                // 更新执行过程区域
                const executionDiv = document.getElementById('bfs-execution');
                const newEntry = document.createElement('div');
                newEntry.className = 'p-2 border-b border-gray-100';
                newEntry.innerHTML = `<strong>${steps.length > 0 ? currentStep + 1 : 0}/${steps.length}</strong>: ${step.message}`;
                executionDiv.appendChild(newEntry);
                executionDiv.scrollTop = executionDiv.scrollHeight;
                
                // 更新进度条
                const progress = ((currentStep + 1) / steps.length) * 100;
                document.getElementById('bfs-progress-bar').style.width = `${progress}%`;
                
                // 高亮当前代码行
                if (step.codeLine !== -1) {
                    document.getElementById(`code-${step.codeLine}`).classList.add('code-line-highlight');
                }
                
                // 更新节点状态
                step.visited.forEach(nodeId => {
                    const node = document.querySelector(`.bfs-node[data-node="${nodeId}"]`);
                    if (node) {
                        node.classList.remove('bfs-node-unvisited');
                        node.classList.add('bfs-node-visited');
                    }
                });
                
                // 高亮当前节点
                if (step.current) {
                    const currentNode = document.querySelector(`.bfs-node[data-node="${step.current}"]`);
                    if (currentNode) {
                        currentNode.classList.add('bfs-node-current');
                    }
                }
                
                // 高亮边（如果是发现邻居步骤）
                if (step.type === 'discover' && step.current && step.neighbor) {
                    document.querySelectorAll('.bfs-edge').forEach(edge => {
                        const from = edge.getAttribute('data-from');
                        const to = edge.getAttribute('data-to');
                        
                        if ((from === step.current && to === step.neighbor) || 
                            (from === step.neighbor && to === step.current)) {
                            edge.classList.remove('bfs-edge');
                            edge.classList.add('bfs-edge-active');
                        }
                    });
                }
                
                // 高亮路径（如果是找到终点步骤）
                if (step.type === 'found' && step.path) {
                    step.path.forEach(nodeId => {
                        const node = document.querySelector(`.bfs-node[data-node="${nodeId}"]`);
                        if (node) {
                            node.classList.remove('bfs-node-visited', 'bfs-node-current');
                            node.classList.add('bfs-node-path');
                        }
                    });
                    
                    // 高亮路径上的边
                    for (let i = 0; i < step.path.length - 1; i++) {
                        const fromNode = step.path[i];
                        const toNode = step.path[i + 1];
                        
                        document.querySelectorAll('.bfs-edge').forEach(edge => {
                            const from = edge.getAttribute('data-from');
                            const to = edge.getAttribute('data-to');
                            
                            if ((from === fromNode && to === toNode) || 
                                (from === toNode && to === fromNode)) {
                                edge.classList.remove('bfs-edge', 'bfs-edge-active');
                                edge.classList.add('bfs-edge-path');
                            }
                        });
                    }
                }
                
                // 更新队列显示
                const queueDiv = document.getElementById('queue-status');
                if (step.queue.length === 0) {
                    queueDiv.innerHTML = '<div class="text-gray-500 italic">队列是空的</div>';
                } else {
                    queueDiv.innerHTML = '';
                    step.queue.forEach(nodeId => {
                        const nodeDiv = document.createElement('div');
                        nodeDiv.className = 'bfs-node bfs-node-visited';
                        nodeDiv.textContent = nodeId;
                        queueDiv.appendChild(nodeDiv);
                    });
                }
            }
            
            // 运行动画
            function runAnimation() {
                const start = document.getElementById('start-node').value;
                const end = document.getElementById('end-node').value;
                
                if (start === end) {
                    alert('起点和终点不能相同！');
                    return;
                }
                
                // 如果是重新开始，重置动画
                if (currentStep > 0) {
                    resetAnimation();
                }
                
                generateSteps(start, end);
                
                if (steps.length === 0) return;
                
                // 切换按钮状态
                document.getElementById('bfs-run').classList.add('hidden');
                document.getElementById('bfs-pause').classList.remove('hidden');
                
                // 执行第一步
                executeStep(steps[currentStep]);
                currentStep++;
                
                // 设置定时器执行后续步骤
                animationInterval = setInterval(() => {
                    if (currentStep < steps.length) {
                        executeStep(steps[currentStep]);
                        currentStep++;
                    } else {
                        clearInterval(animationInterval);
                        document.getElementById('bfs-status').textContent = '状态: 动画演示完成';
                        document.getElementById('bfs-run').classList.remove('hidden');
                        document.getElementById('bfs-pause').classList.add('hidden');
                    }
                }, animationSpeed);
            }
            
            // 单步执行
            function stepAnimation() {
                const start = document.getElementById('start-node').value;
                const end = document.getElementById('end-node').value;
                
                if (start === end) {
                    alert('起点和终点不能相同！');
                    return;
                }
                
                // 如果是第一步，生成步骤
                if (steps.length === 0) {
                    generateSteps(start, end);
                }
                
                // 如果还有步骤未执行
                if (currentStep < steps.length) {
                    executeStep(steps[currentStep]);
                    currentStep++;
                    
                    // 如果已经完成所有步骤
                    if (currentStep >= steps.length) {
                        document.getElementById('bfs-status').textContent = '状态: 动画演示完成';
                    }
                } else {
                    document.getElementById('bfs-status').textContent = '状态: 已完成所有步骤，请重置';
                }
            }
            
            // 暂停动画
            function pauseAnimation() {
                clearInterval(animationInterval);
                document.getElementById('bfs-run').classList.remove('hidden');
                document.getElementById('bfs-pause').classList.add('hidden');
                document.getElementById('bfs-status').textContent = '状态: 已暂停';
            }
            
            // 设置动画速度
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // 更新按钮状态
                    document.querySelectorAll('.speed-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // 更新速度
                    animationSpeed = parseInt(this.getAttribute('data-speed'));
                    
                    // 如果动画正在运行，重新启动定时器
                    if (document.getElementById('bfs-pause').classList.contains('hidden') === false) {
                        clearInterval(animationInterval);
                        animationInterval = setInterval(() => {
                            if (currentStep < steps.length) {
                                executeStep(steps[currentStep]);
                                currentStep++;
                            } else {
                                clearInterval(animationInterval);
                                document.getElementById('bfs-status').textContent = '状态: 动画演示完成';
                                document.getElementById('bfs-run').classList.remove('hidden');
                                document.getElementById('bfs-pause').classList.add('hidden');
                            }
                        }, animationSpeed);
                    }
                });
            });
            
            // 代码复制功能
            document.getElementById('copy-code').addEventListener('click', function() {
                const codeElement = document.getElementById('bfs-code');
                let codeText = '';
                
                codeElement.querySelectorAll('.code-line').forEach(line => {
                    // 替换HTML实体为实际字符
                    let text = line.textContent.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&nbsp;/g, ' ');
                    codeText += text + '\n';
                });
                
                navigator.clipboard.writeText(codeText).then(() => {
                    const originalText = this.innerHTML;
                    this.innerHTML = '<i class="fa fa-check mr-1"></i> 已复制';
                    setTimeout(() => {
                        this.innerHTML = originalText;
                    }, 2000);
                });
            });
            
            // 代码块复制功能
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    const codeBlock = document.getElementById(targetId);
                    const codeText = codeBlock.textContent;
                    
                    navigator.clipboard.writeText(codeText).then(() => {
                        const originalText = this.innerHTML;
                        this.innerHTML = '<i class="fa fa-check mr-1"></i> 已复制';
                        setTimeout(() => {
                            this.innerHTML = originalText;
                        }, 2000);
                    });
                });
            });
            
            // 绑定按钮事件
            document.getElementById('bfs-run').addEventListener('click', runAnimation);
            document.getElementById('bfs-pause').addEventListener('click', pauseAnimation);
            document.getElementById('bfs-step').addEventListener('click', stepAnimation);
            document.getElementById('bfs-reset').addEventListener('click', resetAnimation);
            
            // 平滑滚动
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    
                    document.querySelector(this.getAttribute('href')).scrollIntoView({
                        behavior: 'smooth'
                    });
                });
            });
        });
    </script>
</body>
</html>
